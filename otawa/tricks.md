# initial build
run build.sh

# Incremental Build
run make install

## Problems with header files?
The build system doesn't properly take care of them. If you changed a header file,
copy it manually from otawa-core-build/ over its equivalent within otawa-core/.

# ISS Simulator
Functional only, no timing: arm-sim (generated by GLISS)
Cycle-level ISS: ogensim (based on SystemC)

## Setup of ogensim
Needs simulator enabled in otawa build, otherwise:
  ogensim main.elf -p ~/async/WCET_gitlab/otawa/linux-x86_64/otawa-core/share/Otawa/scripts/generic/pipeline.xml
  ERROR: no functional simulator with the current loader

 1. conjecture: simulator needs to be turned on in otawa to get ARM SimState in ogensim -> set CMAKE bool
 2. this in turn requires WITH_MEM_SPY in gliss loader
 3. setting it in armv7 config.h
 -> requires clean -> deletes arm.nml arm.irg and nmp/state.nmp
 -> building again -> done
 ->
 -> building otawa again
 -> generates otawa_multi/kind/target/sem
 -> sem.h fails:
ERROR: attribute otawa_sem in VSTRS_SD___LT_S___ISD_RT_ at armv7t.nmp:387 is not stateless as it should be!
Seems that armv7t is incompatible

 3. Trying again with armv5t module
 -> mem_spy enabled
 -> it builds successfuly
 => change OTAWA to armv5t loader => if prefers ARM7, but if folder is renamed, defaults to ARM5 => re-run 'make build' => makefile loop
 => try 'make  clean && make' in otawa -> cmake runs again -> otawa builds -> '/home/becker/async/WCET_gitlab/otawa/linux-x86_64/otawa-core-build/armv7t/arm.irg
 => go into src/arm2, remove armv7t.nmp, run 'cmake' -> builds
 => back to OTAWA build: make -> builds!
 => the makefile loop persists... "can's cd to armv7t" -> sed -i 's/armv7/armv5/g' linux-x86_64/otawa-core-build/Makefile

DONE! Now we only need to complete ogensim (because it isn't).

# Simulator timing vs OTAWA timing
## Pitfalls
Caches:
 * Caches and backing memory are configured independently. Therefore, cache miss penalty should
be checked for consistency with memory bank latency. Default values are consistent, thought
 * caches are only modeled if bank has "isCached" property (enabled by default).
 * Multi-level caches could be modeled, but it's unclear whether analysis supports it
 * ''simulator and analyzer disagree when caches off'':
   * OTAWA assumes does not model backing memory access in this case (only BB time <=> always hit)
   * simulation *does* add memory access time to each *instruction*
   * workaround:
     * set memory bank latency to 1 -> ogensim assumes no delay for each insn <=> always hit

Insn timing:s
 * by default, OTAWA assumes each insn takes one clock cycle to execute (modulo d-cache, if any)
 * alternatively, OTAWA can use simulator (timing from where?)

## Simulator
I-Fetch time:
 * accesses a memory bank (DRAM, by default), via caches if specified.
 * cache miss -> bank latency

Exec time:
 * given by functional unit that is claimed. By default each takes one cycle.

## OTWA
I-Fetch time:
 * if caches are on: add cache miss penalty for misses, taken from cacheConfig (!not from bank!)
   * thus, if there is a memory bank accessed, cache config must have the correct miss penalty set.
   * hit time: zero
 * if caches are off:
   * no memory access is modeled either
   * equivalent to always hit.

Insn Timings (multiple options):
 * NO: GraphBBTime: execution graph method for superscalar processors.
 * TBD: tsim::BBTimeSimulator: uses simulator to get BB exec time (reset, run, read off) -> where timing???
   * same as ogensim. It comes from SimState()
 * YES: ipet::TrivialBBTime: insn * pipeline depth => good enough for us.
   * default: depth=5
 * edge time??

# Manipulating ILP System manually
E.g., if constraints are not expressive enough.

1. run owcet with -i (--dump-ilp)
 => creates *.lp file

2. modify file:
  get BB numbers from graphs (<step processor="otawa::display::CFGOutput"/>)

3. run lp_solve manually
/usr/bin/lp_solve < *.lp


