"""Module providing generators for different types of distributions."""

# Dependencies Management
#
# A package is made of 2 sets of modules:
#	* Pp = packaged modules
#	* Ip = included modules.
#
# In turn, modules defines 2 sets of modules:
#	* Ri = required modules,
#	* Ui = used modules.
#
# The following module sets are built by the generator:
#	* I = installed modules,
#	* D = downloaded modules,
#	* R = required modules.
#
# The following rules are used to build this sets:
#	* Required modules are first taken in the current package, else taken in the environment.
#	* Only packaged modules are installed.
#
# The following formulae are used:
#	D = Pp U Ip
#	I = Pp U (U{i in I} Ri n D)
#	R = (U{i in I} Ri) \ I
#

import base
import datetime
import os
import shutil
import sys

class Generator:
	pack = None
	site = None
	env = None
	todownload = None
	tobuild = None
	toinstall = None
	torequire = None
	externs = None
	map = None

	def __init__(self, pack, site):
		self.pack = pack
		self.site = site
		self.env = pack.env
		self.map = {}
		for m in self.pack.names + self.pack.includes:
			self.get_my_module(m)	

	def get_defs(self):
		"""Get the list of definitions."""
		defs = []
		for mod in self.get_tobuild():
			for d in mod.get_defs():
				if d not in defs:
					defs.append(d)
		return defs

	def get_my_module(self, name):
		"""Get a module that will be included in the built package."""
		if self.map.has_key(name):
			return self.map[name]
		mpath = os.path.join(self.pack.spath, name)
		mod = self.env.loadModuleDescriptor(name, mpath, self.pack.env, self.pack)
		self.map[name] = mod
		return mod

	def get_module(self, name):
		"""Get a module by its name."""
		if self.map.has_key(name):
			return self.map[name]
		m = self.site.look(name)
		if m:
			self.map[name] = m
			return m
		else:
			# TODO
			return self.get_my_module(name)
			#raise base.BuildException("cannot find module %s" % name)

	def get_todownload(self):
		"""Get the list of modules to download."""
		if self.todownload == None:
			self.todownload = \
				[self.get_module(n) for n in self.pack.names] + \
				[self.get_module(n) for n in self.pack.includes]
		return self.todownload
	
	def get_toinstall(self):
		"""Get the list of blocks to install."""
		if self.toinstall == None:
			D = self.get_todownload()
			Pp = [self.get_module(name) for name in self.pack.names]
			todo = list(Pp)
			while todo:
				m = todo.pop()
				for n in m.requirements:
					r = self.get_module(n)
					if r in D and r not in Pp:
						Pp.append(r)
						todo.append(r)
			self.toinstall = Pp
		return self.toinstall

	def get_tobuild(self):
		"""Get the list of modules to build."""
		return self.get_todownload()
	
	def get_torequire(self):
		"""Get the list of blocks to require."""
		if self.torequire == None:
			I = self.get_toinstall()
			R = []
			for m in I:
				for n in m.requirements:
					r = self.get_module(n)
					if (r not in I) and (r not in R):
						R .append(r)
			self.torequire = R
		return self.torequire

	def gen_makefile(self, mpath):
		"""Generate the Makefile."""
		try:
			
			# write header
			makefile_path = os.path.join(mpath, "Makefile")
			out = open(makefile_path, "w")
			out.write("# generated by PACKAGE V%s (%s)\n\nPREFIX=/usr\n" % (
				base.VERSION,
				datetime.datetime.today(),
			))
			
			# support for multi-core
			for d in self.get_defs():
				out.write(d.definitions())
			out.write("\n")

			# module importation
			for m in self.get_tobuild():
				out.write("export BASE_%s = $(PREFIX)\n" % m.name)
			out.write("all: %s\n\ninstall: %s\n\n" % (
				" ".join([m.name + "-all" for m in self.get_tobuild()]),
				" ".join([m.name + "-install" for m in self.get_toinstall()])
			))
			out.write("\n")
			
			# generate rules
			for mod in self.get_tobuild():
				
				# setup rules
				self.env.writeRule(
					out,
					mod,
					".setup-%s" % mod.name,
					"",
					mod.doSetup() + ["date > ../$@"])
				
				# all rules
				self.env.writeRule(
					out,
					mod,
					"%s-all" % mod.name,
					" ".join(
							[self.map[m].name + "-install" for m in (mod.requirements + mod.uses) if self.map.has_key(m) and self.map[m] in self.get_toinstall()] + 
							[self.map[m].name + "-all" for m in (mod.requirements + mod.uses) if self.map.has_key(m) and self.map[m] in self.get_tobuild() and self.map[m] not in self.get_toinstall()] + 
							[".setup-%s" % mod.name]),
					["@echo \"*** making %s ***\"" % mod.name] + mod.make())
				
				# install rules
				if mod in self.get_toinstall():
					self.env.writeRule(
						out,
						mod,
						"%s-install" % mod.name,
							"%s-all " % mod.name
							+ " ".join([self.map[m].name + "-install" for m in mod.requirements if self.map[m] in self.toinstall]),
						mod.install())

			out.close()
		except IOError, e:
			self.env.error("error during Makefile creation: %s" % e)

	def get_provided(self):
		"""Get the provided modules."""
		return self.get_toinstall()
	
	def get_requirements(self):
		"""Get the required modules."""
		return self.get_torequire()

	def gen_log_header(self):
		self.env.log.write("====== log for %s (%s) ======\n" % (self.pack.name, datetime.datetime.today()))
		self.env.log.write("host architecture  : %s\n" % self.env.get_host_arch())
		self.env.log.write("target architecture: %s\n" % self.env.get_target_arch())
		self.env.log.write("\n")

	def build(self, btype = base.BUILD_DEV | base.BUILD_BIN):
		"""Build the distribution."""
		pass


class Binary(Generator):
	"""Generatory for a binary distribution."""
	
	def __init__(self, pack, site):
		Generator.__init__(self, pack, site)
	
	def build(self, btype = base.BUILD_DEV | base.BUILD_BIN):
		"""Build a distribution for the given modules."""
		self.gen_log_header()
		suffix = ""
		if btype == base.BUILD_DEV:
			suffix = "-dev"
		
		# collect all modules
		#self.close_mods()
		if self.env.verbose:
			self.env.info("TO BUILD: [" + ", ".join([m.name for m in self.get_tobuild()]) + "]\n")
			self.env.info("TO INSTALL: [" + ", ".join([m.name for m in self.get_toinstall()]) + "]\n")
			self.env.info("EXTERNS: [" + ", ".join([m.name for m in self.get_torequire()]) + "]\n")
		
		# prepare directories
		pwd = os.getcwd()
		cmd = os.path.realpath(sys.argv[0])
		prefix = self.pack.path + suffix
		if os.path.exists(prefix):
			self.env.remove(prefix)
		self.env.makedir(prefix)
		if os.path.exists(self.pack.spath):
			self.env.remove(self.pack.spath)
		self.env.makedir(self.pack.spath)
		os.chdir(self.pack.spath)

		# generate files
		self.gen_makefile(self.pack.spath)
		if self.pack.install_util:
			shutil.copy(os.path.join(os.path.dirname(cmd), "install.py"), prefix)

		# download
		for mod in self.get_todownload():
			mod.download()
		
		# build and install
		opts = ""
		for r in self.get_torequire():
			opts = "%s BASE_%s=%s" % (opts, r.name, r.package.path)
		if self.env.is_cross():
			opts = "%s TARGET_OS=%s" % (opts, self.env.target_arch)
		for k in self.env.params.keys():
			opts = opts + " %s=%s" % (k, self.env.params[k])
		self.env.execute_with_trace("make install PREFIX='%s' INSTALL_TYPE=%s %s" % (prefix, base.BUILD_TYPES[btype], opts))
		
		# copy addons
		os.chdir(pwd)
		for a in self.pack.addons:
			a.onBinDist(self.pack)
		
		# build modules and requirements
		self.pack.mods = self.get_provided()					
		self.pack.requirements = [m.name for m in self.get_requirements()]
		self.pack.save()

		# package
		os.chdir(os.path.dirname(prefix))
		if self.pack.arc_list:
			list = ["%s/%s" % (os.path.basename(prefix), f) for f in self.pack.arc_list]
		else:
			list = [os.path.basename(prefix)]
		self.env.execute("tar cvfj ../%s-%s%s%s.tar.bz2 %s" % (self.pack.name, self.pack.tag, self.env.get_target_arch(), suffix, " ".join(list)))
		os.chdir(pwd)


class Source(Generator):
	
	def __init__(self, pack, site):
		Generator.__init__(self, pack, site)
		self.toinstall = []

	def build(self, btype = base.BUILD_DEV | base.BUILD_BIN):
		"""Build a distribution for the given modules."""
		self.gen_log_header()

		# collect all modules
		#self.close_mods()
		if self.env.verbose:
			self.env.info("TO BUILD: [" + ", ".join([m.name for m in self.get_tobuild()]) + "]\n")
			self.env.info("TO INSTALL: [" + ", ".join([m.name for m in self.get_toinstall()]) + "]\n")
			self.env.info("EXTERNS: [" + ", ".join([m.name for m in self.get_torquire()]) + "]\n")

		# prepare directories
		pwd = os.getcwd()
		cmd = os.path.realpath(sys.argv[0])
		prefix = os.path.join(pwd, "sources", self.pack.name)
		if os.path.exists(prefix):
			self.env.remove(prefix)
		self.env.makedir(prefix)
		os.chdir(prefix)

		# generate files
		self.gen_makefile(prefix)
		if self.pack.install_util:
			shutil.copy(os.path.join(os.path.dirname(cmd), "install.py"), prefix)

		# download
		for mod in self.get_todownload():
			mod.download()
		
		# copy addons
		os.chdir(pwd)
		for a in self.pack.addons:
			a.onSourceDist(self.pack)
		
		# package
		os.chdir(os.path.dirname(prefix))
		list = [os.path.basename(prefix)]
		self.env.execute("tar cvfj ../%s-%ssrc.tar.bz2 %s" % (self.pack.name, self.pack.tag, " ".join(list)))
		os.chdir(pwd)
