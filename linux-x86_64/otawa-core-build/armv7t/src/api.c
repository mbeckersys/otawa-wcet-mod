/* Generated by gep (118/02/19 18:37:34) copyright (c) 2008 IRIT - UPS */

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <arm/api.h>
#include "platform.h"
#include <arm/env.h>
#include <arm/macros.h>
#include <arm/config.h>


static char *arm_string_ident[] = {
	"ARM_UNKNOWN",
	"ARM_UXTAHS_S__S__SS",
	"ARM_UXTAB16S_S__S__SS",
	"ARM_UXTABS_S__S__SS",
	"ARM_USUB8S_S__S__S",
	"ARM_USUB16S_S__S__S",
	"ARM_USAXS_S__S__S",
	"ARM_USATS_S___ID__SS",
	"ARM_USADA8S_S__S__S__S",
	"ARM_UQSUB8S_S__S__S",
	"ARM_UQSUB16S_S__S__S",
	"ARM_UQSAXS_S__S__S",
	"ARM_UQASXS_S__S__S",
	"ARM_UQADD8S_S__S__S",
	"ARM_UQADD16S_S__S__S",
	"ARM_UMULLS_S__S__S__S",
	"ARM_UMLALS_S__S__S__S",
	"ARM_UMAALS_S__S__S__S",
	"ARM_UHSUB8S_S__S__S",
	"ARM_UHSUB16S_S__S__S",
	"ARM_UHSAXS_S__S__S",
	"ARM_UHASXS_S__S__S",
	"ARM_UHADD8S_S__S__S",
	"ARM_UHADD16S_S__S__S",
	"ARM_UDIVS_S__S__S",
	"ARM_UBFXS_S__S___ID___ID",
	"ARM_UASXS_S__S__S",
	"ARM_UADD8S_S__S__S",
	"ARM_UADD16S_S__S__S",
	"ARM_SXTAHS_S__S__SS",
	"ARM_SXTAB16S_S__S__SS",
	"ARM_SXTABS_S__S__SS",
	"ARM_SUBSS_W_S__S__SS",
	"ARM_SUBWS_S__S___ID_",
	"ARM_SUBSS_W_S__S___IU",
	"ARM_SSUB8S_S__S__S",
	"ARM_SSUB16S_S__S__S",
	"ARM_SSAXS_S__S__S",
	"ARM_SSATS_S___ID__SS",
	"ARM_SMULLS_S__S__S__S",
	"ARM_SMMLSSS_S__S__S__S",
	"ARM_SMMLASS_S__S__S__S",
	"ARM_SMLSLDSS_S__S__S__S",
	"ARM_SMLSDSS_S__S__S__S",
	"ARM_SMLAWSS_S__S__S__S",
	"ARM_SMLALDSS_S__S__S__S",
	"ARM_SMLALSSS_S__S__S__S",
	"ARM_SMLALS_S__S__S__S",
	"ARM_SMLADSS_S__S__S__S",
	"ARM_SMLASSS_S__S__S__S",
	"ARM_SHSUB8S_S__S__S",
	"ARM_SHSUB16S_S__S__S",
	"ARM_SHSAXS_S__S__S",
	"ARM_SHASXS_S__S__S",
	"ARM_SHADD8S_S__S__S",
	"ARM_SHADD16S_S__S__S",
	"ARM_SELS_S__S__S",
	"ARM_SDIVS_S__S__S",
	"ARM_SBFXS_S__S___ID___ID",
	"ARM_SBCSS_W_S__S__SS",
	"ARM_SBCSS_W_S__S___IU",
	"ARM_SASXS_S__S__S",
	"ARM_SADD8S_S__S__S",
	"ARM_SADD16S_S__S__S",
	"ARM_RSBSS_S__S__SS",
	"ARM_RORSS_W_S__S__S",
	"ARM_REVSHS_W_S__S",
	"ARM_REV16S_W_S__S",
	"ARM_REVS_W_S__S",
	"ARM_RBITS_S__S",
	"ARM_QSUB8S_S__S__S",
	"ARM_QSUB16S_S__S__S",
	"ARM_QSUBS_S__S__S",
	"ARM_QSAXS_S__S__S",
	"ARM_QDSUBS_S__S__S",
	"ARM_QDADDS_S__S__S",
	"ARM_QASXS_S__S__S",
	"ARM_QADD8S_S__S__S",
	"ARM_QADD16S_S__S__S",
	"ARM_QADDS_S__S__S",
	"ARM_PKHBTS_S__S__SS",
	"ARM_ORNSS_S__S__SS",
	"ARM_ORNSS_S__S___IU",
	"ARM_MRRCSS_D__D__S__S__CRD",
	"ARM_MRCSS_D__D__S__CRD__CRD___LB_D_RB_",
	"ARM_MLSS_S__S__S__S",
	"ARM_MLAS_S__S__S__S",
	"ARM_MCRRSS_D__D__S__S__CRD",
	"ARM_MCRSS_D__D__S__CRD__CRD___LB_D_RB_",
	"ARM_LSRSS_W_S__S__S",
	"ARM_LDMDBS_SS___LB_S_RB_",
	"ARM_EORSS_W_S__S__SS",
	"ARM_EORSS_W_S__S___IU",
	"ARM_CLZS_S__S",
	"ARM_CDPSS_D__D__CRD__CRD__CRD___LB_D_RB_",
	"ARM_BICSS_W_S__S__SS",
	"ARM_BICSS_W_S__S___IU",
	"ARM_BFIS_S__S___ID___ID",
	"ARM_BS_W_08X",
	"ARM_BS_W_08X_0",
	"ARM_MOVTS_S___ID",
	"ARM_ORRS_W_S__S__SS",
	"ARM_MOVWS_S___ID",
	"ARM_ORRSS_W_S__S___IU",
	"ARM_ASRSS_W_S__S__S",
	"ARM_ANDSS_W_S__S__SS",
	"ARM_ANDSS_W_S__S___IU",
	"ARM_ADDSS_W_S__S__SS",
	"ARM_ADDWS_S__S___ID_",
	"ARM_ADDSS_W_S__S___IU",
	"ARM_ADCSS_W_S__S__SS",
	"ARM_ADCSS_W_S__S___IU",
	"ARM_PLIS__LT_S__S_RT_",
	"ARM_PLIS__LT_PC_RT_",
	"ARM_PLIS__LT_S_RT_",
	"ARM_PLIS__LT_S_RT__0",
	"ARM_PLDSS__LT_S__S_RT_",
	"ARM_PLDSS__LT_S_RT_",
	"ARM_PLDSS__LT_S_RT__0",
	"ARM_RSBSS_W_S__S___ID",
	"ARM_LSLSS_W_S__S__S",
	"ARM_LDRDS_S__S___LT_SS",
	"ARM_STRDS_S__S___LT_SS",
	"ARM_STREXHS_S__S___LT_S_RT_",
	"ARM_STREXBS_S__S__S___LT_S_RT_",
	"ARM_STREXBS_S__S___LT_S_RT_",
	"ARM_STREXS_S__S___LT_S_RT_",
	"ARM_LDREXHS_S___LT_S_RT_",
	"ARM_LDREXBS_S___LT_S_RT_",
	"ARM_LDREXBS_S___LT_S_RT__0",
	"ARM_LDREXS_S___LT_S_RT_",
	"ARM_STMSS_SS___LB_SSSSSSSSSSSSSSS_RB_",
	"ARM_LDRSHS_S___LT_S_RT____IS0XX",
	"ARM_LDRSHS_S___LT_S___I0XX_RT_",
	"ARM_LDRSBS_S___LT_PC_RT_",
	"ARM_LDRSBS_S___LT_S_RT____IS0XX",
	"ARM_LDRSBS_S___LT_S___I0XX_RT_",
	"ARM_LDRBS_S___LT_S_RT____IS0XX",
	"ARM_LDRBS_W_S___LT_S___I0XX_RT_",
	"ARM_STRBS_S___LT_SS",
	"ARM_STRBS_W_S___LT_S___I0XX_RT_",
	"ARM_STRS_S___LT_S_RT____IS0XX",
	"ARM_STRS_W_S___LT_S___I0XX_RT_",
	"ARM_LDMSS_W_SS___LB_SSSSSSSSSSSSSSS_RB_",
	"ARM_STRHS_S___LT_S_RT____IS0XX",
	"ARM_STRHS_W_S___LT_S_RT_",
	"ARM_LDRHS_S___LT_S_RT____IS0XX",
	"ARM_LDRHS_W_S___LT_S_RT_",
	"ARM_LDRSHS_W_S___LT_S__S_RT_",
	"ARM_STRHS_W_S___LT_S__S_RT_",
	"ARM_LDRHS_W_S___LT_S__S_RT_",
	"ARM_LDRS_S___LT_S_RT____IS0XX",
	"ARM_LDRS_W_S___LT_S___I0XX_RT_",
	"ARM_LDRSHTS_S___LT_S_RT_",
	"ARM_LDRSBTS_S___LT_S_RT_",
	"ARM_STRTS_S___LT_S_RT_",
	"ARM_LDRTS_S___LT_S_RT_",
	"ARM_STRHTS_S___LT_S_RT_",
	"ARM_LDRHTS_S___LT_S_RT_",
	"ARM_STRBTS_S___LT_S_RT_",
	"ARM_LDRBTS_S___LT_S_RT_",
	"ARM_LDRSBS_W_S___LT_S__S_RT_",
	"ARM_STRBS_W_S___LT_S__S_RT_",
	"ARM_LDRBS_W_S___LT_S__S_RT_",
	"ARM_STRS_W_S___LT_S__S_RT_",
	"ARM_LDRS_W_S___LT_S__S_RT_",
	"ARM_LDC2SS_D__D___LT_RD_RT___D",
	"ARM_LDC2SS_D__D___LT_RD_RT____ISD",
	"ARM_LDC2SS_D__D___LT_RD___ISD_RT__21",
	"ARM_LDC2SS_D__D___LT_RD___ISD_RT_",
	"ARM_LDCSS_D__D___LT_RD_RT___D",
	"ARM_LDCSS_D__D___LT_RD_RT____ISD",
	"ARM_LDCSS_D__D___LT_RD___ISD_RT__21",
	"ARM_LDCSS_D__D___LT_RD___ISD_RT_",
	"ARM_STC2SS_D__D___LT_RD_RT___D",
	"ARM_STC2SS_D__D___LT_RD_RT____ISD",
	"ARM_STC2SS_D__D___LT_RD___ISD_RT__21",
	"ARM_STC2SS_D__D___LT_RD___ISD_RT_",
	"ARM_STCSS_D__D___LT_RD_RT___D",
	"ARM_STCSS_D__D___LT_RD_RT____ISD",
	"ARM_STCSS_D__D___LT_RD___ISD_RT__21",
	"ARM_STCSS_D__D___LT_RD___ISD_RT_",
	"ARM_BLXS_0X08X",
	"ARM_TBBS__LT_S__S_RT_",
	"ARM_BLS_0XX",
	"ARM_VSS_F64_DD__DD__DD",
	"ARM_VSS_F32_SD__SD__SD",
	"ARM_VSS_F32_QD__QD__QD",
	"ARM_VSS_F32_DD__DD__DD",
	"ARM_VPOPS__LB_SD_RB_",
	"ARM_VPOPS__LB_DD_RB_",
	"ARM_VADDS_F64_DD__DD__DD",
	"ARM_VADDS_F32_SD__SD__SD",
	"ARM_VADDS_F32_QD__QD__QD",
	"ARM_VADDS_F32_DD__DD__DD",
	"ARM_VCVTS_F64_S_DD__SD",
	"ARM_VCVTSS_U32_F64_SD__DD",
	"ARM_VCVTS_F32_S_SD__SD",
	"ARM_VPUSHS__LB_SD_RB_",
	"ARM_VPUSHS__LB_DD_RB_",
	"ARM_VMULS_F64_DD__DD__DD",
	"ARM_VMULS_F32_SD__SD__SD",
	"ARM_VMULS_F32_QD__QD__QD",
	"ARM_VMULS_F32_DD__DD__DD",
	"ARM_VMRSS_S__FPSCR",
	"ARM_VSTRS_SD___LT_S___ISD_RT_",
	"ARM_VSTRS_DD___LT_S___ISD_RT_",
	"ARM_VLDRS_DD___LT_S___ISD_RT_",
	"ARM_VLDRS_DD___LT_S___ISD_RT__0",
	"ARM_VDIVS_F64_DD__DD__DD",
	"ARM_VDIVS_F32_SD__SD__SD",
	"ARM_VSUBS_F64_DD__DD__DD",
	"ARM_VSUBS_F32_SD__SD__SD",
	"ARM_VMOVS_DD__S__S",
	"ARM_VMOVS_SD__S",
	"ARM_VMOVS_F64_DD__DD",
	"ARM_VMOVS_F32_SD__SD",
	"ARM_VMOVS_F64_DD___ID",
	"ARM_VMOVS_F32_SD___ID",
	"ARM_UXTHS_RD__RD",
	"ARM_UXTBS_RD__RD",
	"ARM_YIELDS",
	"ARM_MOVS_S__S",
	"ARM_MOVS_RD___ID",
	"ARM_TSTS_RD__RD",
	"ARM_SXTHS_RD__RD",
	"ARM_SXTBS_RD__RD",
	"ARM_SUBS_RD__RD__RD",
	"ARM_SUBS_SP___ID",
	"ARM_SUBS_RD___ID",
	"ARM_SUBS_RD__RD___ID",
	"ARM_STRHS_RD___LT_RD__RD__RT_",
	"ARM_STRHS_RD___LT_RD___I0XX_RT_",
	"ARM_STRBS_RD___LT_RD__RD_RT_",
	"ARM_STRBS_RD___LT_RD___ID_RT_",
	"ARM_STRS_RD___LT_SP___ID_RT_",
	"ARM_STRS_RD___LT_RD__RD_RT_",
	"ARM_STRS_RD___LT_RD___I0XX_RT_",
	"ARM_STMIAS_RD_21___LB_S_RB_",
	"ARM_SBCS_RD__RD",
	"ARM_RORS_RD__RD",
	"ARM_REVSHS_RD__RD",
	"ARM_REV16S_RD__RD",
	"ARM_REVS_RD__RD",
	"ARM_PUSHS__LB_SS_RB_",
	"ARM_PUSHS__LB_SS_RB__0",
	"ARM_POPS__LB_SS_RB_",
	"ARM_POPS__LB_SS_RB__0",
	"ARM_ORRS_RD__RD",
	"ARM_RSBS_RD__RD___I0",
	"ARM_MVNS_RD__RD",
	"ARM_MULS_RD__RD",
	"ARM_LSRS_RD__RD",
	"ARM_LSRS_RD__RD___ID",
	"ARM_LSLS_RD__RD",
	"ARM_LSLS_RD__RD___ID",
	"ARM_LDRSHS_RD___LT_RD__RD_RT_",
	"ARM_LDRSBS_RD___LT_RD__RD_RT_",
	"ARM_LDRHS_RD___LT_RD__RD_RT_",
	"ARM_LDRHS_RD___LT_RD___I0XX_RT_",
	"ARM_LDRBS_RD___LT_RD__RD_RT_",
	"ARM_LDRBS_RD___LT_RD___ID_RT_",
	"ARM_LDRS_RD___LT_SP___I0XX_RT_",
	"ARM_LDRS_RD___LT_PC___I0XX_RT_",
	"ARM_LDRS_RD___LT_RD__RD_RT_",
	"ARM_LDRS_RD___LT_RD___I0XX_RT_",
	"ARM_LDMIAS_RD___LB_S_RB_",
	"ARM_EORS_RD__RD",
	"ARM_CMPS_RD__S",
	"ARM_CMPS_RD__RD",
	"ARM_CMPS_RD___ID",
	"ARM_CMNS_RD__RD",
	"ARM_CBZS_RD__D",
	"ARM_BXS_S",
	"ARM_BLXS_S",
	"ARM_BKPT__ID",
	"ARM_BICS_RD__RD",
	"ARM_BS_N__40",
	"ARM_S_N_08X",
	"ARM_ASRS_RD__RD",
	"ARM_ASRS_RD__RD___ID",
	"ARM_ANDS_RD__RD",
	"ARM_ADDS_S__S",
	"ARM_ADDS_RD__RD__RD",
	"ARM_ADDS_SP__SP___ID",
	"ARM_ADDS_RD__SP___ID",
	"ARM_ADDS_RD__PC___ID",
	"ARM_ADDS_RD___ID",
	"ARM_ADDS_RD__RD___ID",
	"ARM_ADCS_RD__RD",
	"ARM_MRCS_D__D__S__CRD__CRD__D",
	"ARM_LDCSSS_D__D___LT_RD_RT___D",
	"ARM_LDCSSS_D__D___LT_RD_RT____ISD",
	"ARM_LDCSSS_D__D___LT_RD___ISD_RT__21",
	"ARM_LDCSSS_D__D___LT_RD___ISD_RT_",
	"ARM_STCSSS_D__D___LT_RD_RT___D",
	"ARM_STCSSS_D__D___LT_RD_RT____ISD",
	"ARM_STCSSS_D__D___LT_RD___ISD_RT__21",
	"ARM_STCSSS_D__D___LT_RD___ISD_RT_",
	"ARM_VSTRS_SD___LT_S___ISD_RT__0",
	"ARM_VSTRS_DD___LT_S___ISD_RT__0",
	"ARM_VSTMSSS_SS___LB_S_RB_",
	"ARM_VSTMSSS_SS___LB_S_RB__0",
	"ARM_VSTMSSS_SS___LB_S_RB__1",
	"ARM_VSTMSSS_SS___LB_S_RB__2",
	"ARM_VMULS_F64_DD__DD__DD_0",
	"ARM_VMULS_F32_SD__SD__SD_0",
	"ARM_VMUL_F32_QD__QD__QD",
	"ARM_VMUL_F32_DD__DD__DD",
	"ARM_VMOVS_DD__S__S_0",
	"ARM_VMOVS_SD__S_0",
	"ARM_VMOVS_F64_DD__DD_0",
	"ARM_VMOVS_F32_SD__SD_0",
	"ARM_VMOVS_F64_DD___ID_0",
	"ARM_VMOVS_F32_SD___ID_0",
	"ARM_VSS_F64_DD__DD__DD_0",
	"ARM_VSS_F32_SD__SD__SD_0",
	"ARM_VS_F32_QD__QD__QD",
	"ARM_VS_F32_DD__DD__DD",
	"ARM_VLDRS_DD___LT_S___ISD_RT__1",
	"ARM_VLDRS_DD___LT_S___ISD_RT__2",
	"ARM_VLDMDBS_S_21___LB_S_RB_",
	"ARM_VLDMIAS_SS___LB_S_RB_",
	"ARM_VLDMDBS_S_21___LB_S_RB__0",
	"ARM_VLDMIAS_SS___LB_S_RB__0",
	"ARM_VDIVS_F64_DD__DD__DD_0",
	"ARM_VDIVS_F32_SD__SD__SD_0",
	"ARM_VCVT_FD_FD_S__S",
	"ARM_VCVTSS_S_S_S_S",
	"ARM_VADDS_F64_DD__DD__DD_0",
	"ARM_VADDS_F32_SD__SD__SD_0",
	"ARM_VADD_F32_QD__QD__QD",
	"ARM_VADD_F32_DD__DD__DD",
	"ARM_DMB_S",
	"ARM_MRSS_S__CPSR",
	"ARM_MRSS_S__SPSR",
	"ARM_MSRS_CPSR___S",
	"ARM_MSRS_CPSR_FSXC__S",
	"ARM_MSRS_CPSR_SXC__S",
	"ARM_MSRS_CPSR_FXC__S",
	"ARM_MSRS_CPSR_FSX__S",
	"ARM_MSRS_CPSR_XC__S",
	"ARM_MSRS_CPSR_SC__S",
	"ARM_MSRS_CPSR_SX__S",
	"ARM_MSRS_CPSR_F__S",
	"ARM_MSRS_CPSR_FX__S",
	"ARM_MSRS_CPSR_FS__S",
	"ARM_MSRS_CPSR_C__S",
	"ARM_MSRS_CPSR_X__S",
	"ARM_MSRS_CPSR_S__S",
	"ARM_MSRS_CPSR_F__S_0",
	"ARM_MSRS_SPSR___S",
	"ARM_MSRS_SPSR_FSXC__S",
	"ARM_MSRS_SPSR_SXC__S",
	"ARM_MSRS_SPSR_FXC__S",
	"ARM_MSRS_SPSR_FSX__S",
	"ARM_MSRS_SPSR_XC__S",
	"ARM_MSRS_SPSR_SC__S",
	"ARM_MSRS_SPSR_SX__S",
	"ARM_MSRS_SPSR_F__S",
	"ARM_MSRS_SPSR_FX__S",
	"ARM_MSRS_SPSR_FS__S",
	"ARM_MSRS_SPSR_C__S",
	"ARM_MSRS_SPSR_X__S",
	"ARM_MSRS_SPSR_S__S",
	"ARM_MSRS_SPSR_F__S_0",
	"ARM_MSRS_CPSR____ID",
	"ARM_MSRS_CPSR_FSXC___ID",
	"ARM_MSRS_CPSR_SXC___ID",
	"ARM_MSRS_CPSR_FXC___ID",
	"ARM_MSRS_CPSR_FSX___ID",
	"ARM_MSRS_CPSR_XC___ID",
	"ARM_MSRS_CPSR_SC___ID",
	"ARM_MSRS_CPSR_SX___ID",
	"ARM_MSRS_CPSR_F___ID",
	"ARM_MSRS_CPSR_FX___ID",
	"ARM_MSRS_CPSR_FS___ID",
	"ARM_MSRS_CPSR_C___ID",
	"ARM_MSRS_CPSR_X___ID",
	"ARM_MSRS_CPSR_S___ID",
	"ARM_MSRS_CPSR_F___ID_0",
	"ARM_MSRS_SPSR____ID",
	"ARM_MSRS_SPSR_FSXC___ID",
	"ARM_MSRS_SPSR_SXC___ID",
	"ARM_MSRS_SPSR_FXC___ID",
	"ARM_MSRS_SPSR_FSX___ID",
	"ARM_MSRS_SPSR_XC___ID",
	"ARM_MSRS_SPSR_SC___ID",
	"ARM_MSRS_SPSR_SX___ID",
	"ARM_MSRS_SPSR_F___ID",
	"ARM_MSRS_SPSR_FX___ID",
	"ARM_MSRS_SPSR_FS___ID",
	"ARM_MSRS_SPSR_C___ID",
	"ARM_MSRS_SPSR_X___ID",
	"ARM_MSRS_SPSR_S___ID",
	"ARM_MSRS_SPSR_F___ID_0",
	"ARM_CDPSS_D__D__D__D__D__D",
	"ARM_BFIS_S___ID___ID",
	"ARM_CLZS_S__S_0",
	"ARM_SWPS_S__S___LT_S_RT_",
	"ARM_SWPSB_S__S___LT_S_RT_",
	"ARM_UMLALSS_S__S__S__S",
	"ARM_SMLALSS_S__S__S__S",
	"ARM_UMULLSS_S__S__S__S",
	"ARM_SMULLSS_S__S__S__S",
	"ARM_MULSS_S__S__S",
	"ARM_MLASS_S__S__S__S",
	"ARM_SWIS_D",
	"ARM_LDMSS_SS___LB_S_RB_S",
	"ARM_STMSS_SS___LB_S_RB_S",
	"ARM_STREXHS_S__S___LT_S_RT__0",
	"ARM_STREXDS_S__S___LT_S_RT_",
	"ARM_STREXBS_S__S___LT_S_RT__0",
	"ARM_STREXS_S__S___LT_S_RT__0",
	"ARM_LDREXHS_S___LT_S_RT__0",
	"ARM_LDREXDS_S___LT_S_RT_",
	"ARM_LDREXBS_S___LT_S_RT__1",
	"ARM_LDREXS_S___LT_S_RT__0",
	"ARM_STRDS_S___LT_SS__S_IUSS",
	"ARM_LDRSSH_S___LT_SS__SSSS",
	"ARM_LDRSSH_S___LT_SS__S_IUSS",
	"ARM_LDRSSB_S___LT_SS__SSSS",
	"ARM_LDRSSB_S___LT_SS__S_IUSS",
	"ARM_LDRSH_S___LT_SS__SSSS",
	"ARM_LDRSH_S___LT_SS__S_IUSS",
	"ARM_STRHS_S___LT_SS__SSSS",
	"ARM_STRHS_S___LT_SS__S_IUSS",
	"ARM_STRSSS_S___LT_SS__SS__S__IDSS",
	"ARM_LDRSSS_S___LT_SS__SS__S__IDSS",
	"ARM_STRSSS_S___LT_SS__S_IDSS",
	"ARM_LDRSSS_S___LT_SS__S_IDSS",
	"ARM_BSS__40",
	"ARM_BLXS_S_0",
	"ARM_BXS_S_0",
	"ARM_MOVS_S___ID",
	"ARM_MOVTS_S___ID_0",
	"ARM_TSTS_S___ID",
	"ARM_TSTS_S__S__S_S",
	"ARM_TSTS_S__S",
	"ARM_TEQS_S___ID",
	"ARM_TEQS_S__S__S_S",
	"ARM_TEQS_S__S",
	"ARM_SUBSS_S__S___ID",
	"ARM_SUBSS_S__S__S__S_S",
	"ARM_SUBSS_S__S__S",
	"ARM_SBCSS_S__S___ID",
	"ARM_SBCSS_S__S__S__S_S",
	"ARM_SBCSS_S__S__S",
	"ARM_RSCSS_S__S___ID",
	"ARM_RSCSS_S__S__S__S_S",
	"ARM_RSCSS_S__S__S",
	"ARM_RSBSS_S__S___ID",
	"ARM_RSBSS_S__S__S__S_S",
	"ARM_RSBSS_S__S__S",
	"ARM_ORRSS_S__S___ID",
	"ARM_ORRSS_S__S__S__S_S",
	"ARM_ORRSS_S__S__S",
	"ARM_MVNSS_S___ID",
	"ARM_MVNSS_S__S__S_S",
	"ARM_MVNSS_S__S",
	"ARM_MOVSS_S___ID",
	"ARM_MOVSS_S__S__S_S",
	"ARM_MOVSS_S__S",
	"ARM_EORSS_S__S___ID",
	"ARM_EORSS_S__S__S__S_S",
	"ARM_EORSS_S__S__S",
	"ARM_CMPS_S___ID",
	"ARM_CMPS_S__S__S_S",
	"ARM_CMPS_S__S",
	"ARM_CMNS_S___ID",
	"ARM_CMNS_S__S__S_S",
	"ARM_CMNS_S__S",
	"ARM_BICSS_S__S___ID",
	"ARM_BICSS_S__S__S__S_S",
	"ARM_BICSS_S__S__S",
	"ARM_ANDSS_S__S___ID",
	"ARM_ANDSS_S__S__S__S_S",
	"ARM_ANDSS_S__S__S",
	"ARM_ADDSS_S__S__S__S_S",
	"ARM_ADDSS_S__S__S",
	"ARM_ADCSS_S__S___ID",
	"ARM_ADCSS_S__S__S__S_S",
	"ARM_ADCSS_S__S__S",
	"ARM_ADDSS_S__S___ID"
};

/* execution code table */
typedef void (*arm_code_function_t)(arm_state_t *, arm_inst_t *);
extern arm_code_function_t arm_code_table[];


char *arm_get_string_ident(arm_ident_t id)
{
	return arm_string_ident[id];
}

static unsigned long arm_size_ident[] = {
	16,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	16,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32,
	32
};

unsigned long arm_get_inst_size_from_id(arm_ident_t id) {
	return arm_size_ident[id];
}

unsigned long arm_get_inst_size(arm_inst_t* inst) {
	return arm_size_ident[inst->ident];
}

/**
 * @typedef arm_platform_t
 * This opaque type allows to represent an hardware and software platform.
 * It includes information about:
 * @li the hardware memories,
 * @li the module data (including system calls and interruption support).
 */


/**
 * Build a new platform for the platform arm.
 * @return	Created platform or null if there is no more memory (see errno).
 * @note To release the platform, use arm_unlock_platform().
 */
arm_platform_t *arm_new_platform(void) {
	arm_platform_t *pf;

	/* allocation */
	pf = (arm_platform_t *)calloc(1, sizeof(arm_platform_t));
	if(pf == NULL) {
		errno = ENOMEM;
		return NULL;
	}
	/* the new platform is not locked yet */
	pf->usage = 0;

	/* other init */
	/*pf->entry = pf->sp = pf->argv = pf->envp = pf->aux = pf->argc = 0;*/
	pf->sys_env = calloc(1, sizeof(arm_env_t));
	if(pf->sys_env == NULL) {
		errno = ENOMEM;
		free(pf);
		return NULL;
	}

	/* memory initialization */
	pf->mems.named.M = arm_mem_new();
	if(pf->mems.named.M == NULL) {
		free(pf->sys_env);
		free(pf);
		return NULL;
	}


	/* module initialization */
	ARM_MEM_INIT(pf);
	ARM_GRT_INIT(pf);
	ARM_ERROR_INIT(pf);
	ARM_GEN_INT_INIT(pf);
	ARM_LOADER_INIT(pf);
	ARM_CODE_INIT(pf);
	ARM_ENV_INIT(pf);
	ARM_SYS_CALL_INIT(pf);
	ARM_SHIFT_INIT(pf);


	/* return platform */
	return pf;
}


/**
 * Get a memory in the platform.
 * @param platform	Platform to get memory from.
 * @param index		Index of the memory to get.
 * @return			Requested memory.
 */
arm_memory_t *arm_get_memory(arm_platform_t *platform, int index) {
	if (platform == NULL)
		return NULL;

	return platform->mems.array[index];
}


/**
 * return the system info (argc, argv ...), meaningless
 * if used when no program loaded
 * @param	platform	Platform to get system info from.
 * @return		Requested system info.
 */
arm_env_t *arm_get_sys_env(arm_platform_t *platform)
{
	if (platform == NULL)
		return NULL;

	return platform->sys_env;
}


/**
 * Ensure that the platform is not released before a matching
 * arm_platform_unlock() is performed.
 * @param platform	Platform to lock.
 */
void arm_lock_platform(arm_platform_t *platform) {
	if (platform == NULL)
		return;

	platform->usage++;
}


/**
 * Unlock the platform. If it the last lock on the platform,
 * the platform is freed.
 * @param platform	Platform to unlock.
 */
void arm_unlock_platform(arm_platform_t *platform) {
	if (platform == NULL)
		return;

	/* unlock */
	if(--platform->usage != 0)
		return;

	/* destroy the modules */
	ARM_MEM_DESTROY(platform);
	ARM_GRT_DESTROY(platform);
	ARM_ERROR_DESTROY(platform);
	ARM_GEN_INT_DESTROY(platform);
	ARM_LOADER_DESTROY(platform);
	ARM_CODE_DESTROY(platform);
	ARM_ENV_DESTROY(platform);
	ARM_SYS_CALL_DESTROY(platform);
	ARM_SHIFT_DESTROY(platform);


	/* free the memories */
	arm_mem_delete(platform->mems.named.M);


	/* free system info */
	free(platform->sys_env);

	/* free the platform */
	free(platform);
	platform = NULL;
}


/**
 * Load the program from the given loader.
 * @param platform		Platform.
 * @param loader		Loader to get program from.
 */
void arm_load(arm_platform_t *platform, arm_loader_t *loader) {
	assert(platform);

	/* load in platform's memory */
	arm_loader_load(loader, platform);

	/* initialize system information */
	platform->entry = arm_loader_start(loader);
	arm_set_brk(platform, arm_brk_init(loader));

	/* !!TODO!! add argc,argv... init */
	/* stack initialization */
	arm_stack_fill_env(loader, platform, platform->sys_env);
}


/**
 * Load the given program in the platform and initialize stack
 * @param platform	Platform to load in.
 * @param path		Path of the file to load.
 * @return			0 for success, -1 for error (in errno).
 */
int arm_load_platform(arm_platform_t *platform, const char *path) {
	arm_loader_t *loader;
	assert(platform);

	/* open the file */
	loader = arm_loader_open(path);
	if(loader == NULL)
		return -1;

	/* load in platform's memory */
	arm_load(platform, loader);

	/* close the file */
	arm_loader_close(loader);

	/* return success */
	return 0;
}



/* state management function */


/**
 * Create a new initialized state depending on a given platform
 * @param	platform	the platform helping the simulation on the created state
 * @return			a new initialized state suitable for the given platform
 */
arm_state_t *arm_new_state(arm_platform_t *platform)
{
	arm_state_t *state;

	/* allocation */
	state = (arm_state_t *)malloc(sizeof(arm_state_t));
	if(state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* zeroing of all registers and memory references */
	memset(state, 0, sizeof(arm_state_t));

	/* creating platform */
	if(platform == NULL)
	{
		free(state);
		return NULL;
	}
	state->platform = platform;

	/* locking it */
	arm_lock_platform(state->platform);

	/* memory initialization */
	state->M = state->platform->mems.named.M;

	/* proper state initialization (from the op init) */
	ARM_GPR[15] = 8192LU;
	ARM_GPR[14] = 8192LU;
	ARM_GPR[13] = 2048LU;
	ARM_GPR[21] = 1536LU;
	ARM_GPR[23] = 1024LU;
	ARM_GPR[25] = 512LU;
	ARM_GPR[27] = 4096LU;
	ARM_GPR[29] = 4608LU;
	ARM_APSR = ((uint32_t)(19));
	ARM_APSR = arm_set_field32(ARM_APSR, ((uint8_t)(0)), 5, 5);
	ARM_GPR[(13 + 10)] = 2048LU;


	/* PC initialization */
	state->GPR[15] = platform->entry;
#	ifdef ARM_INIT_PC
		ARM_INIT_PC
#	else
		state->GPR[15] = platform->entry;
#	endif


	/* system registers initialization (argv, envp...) */
	arm_registers_fill_env(platform->sys_env, state);

	return state;
}


/**
 * Delete a state
 * @param	state	the state to delete
 */
void arm_delete_state(arm_state_t *state)
{
	if (state == NULL)
		return;

	/* unlock the platform */
	arm_unlock_platform(state->platform);

	/* free the state */
	free(state);
	state = NULL;
}


/**
 * Return a copy of a given state, both state will share the same memory
 * and each new state's register will have the same value as in the given state.
 * the copied state may not be suitable for further simulation as the stack pointers
 * and similar address registers will be identical in two different states
 * sharing the same memory
 *
 * @param	state	the state to copy
 * @return		a fresh allocated copy (to be freed by the caller)
 */
arm_state_t *arm_copy_state(arm_state_t *state)
{
	int i;

	if (state == NULL)
		return NULL;

	/* allocate a new state */
	arm_state_t *new_state = (arm_state_t *)malloc(sizeof(arm_state_t));
	if(new_state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* copy the platform and lock it */
	/* !!WARNING!! is this needed? as we may not wish to simulate with this state */
	new_state->platform = state->platform;
	arm_lock_platform(new_state->platform);

	/* copy all the registers */
	new_state->BBIT = state->BBIT;
	new_state->PBIT = state->PBIT;
	for (i = 0; i < 16; i++)
		new_state->LR_saved[i] = state->LR_saved[i];
	new_state->LBIT = state->LBIT;
	new_state->WBIT = state->WBIT;
	for (i = 0; i < 16; i++)
		new_state->SP_saved[i] = state->SP_saved[i];
	new_state->PSRXMODE = state->PSRXMODE;
	for (i = 0; i < 16; i++)
		new_state->D[i] = state->D[i];
	new_state->MSBIT = state->MSBIT;
	new_state->HBIT = state->HBIT;
	new_state->APSR = state->APSR;
	new_state->SPSR = state->SPSR;
	new_state->NPC = state->NPC;
	new_state->RBIT = state->RBIT;
	new_state->PSRFMODE = state->PSRFMODE;
	for (i = 0; i < 32; i++)
		new_state->S[i] = state->S[i];
	for (i = 0; i < 16; i++)
		new_state->GPR[i] = state->GPR[i];
	new_state->PSRSMODE = state->PSRSMODE;
	for (i = 0; i < 16; i++)
		new_state->SPSR_saved[i] = state->SPSR_saved[i];
	new_state->IBIT = state->IBIT;
	new_state->B15SET = state->B15SET;
	for (i = 0; i < 5; i++)
		new_state->R_saved[i] = state->R_saved[i];
	new_state->UBIT = state->UBIT;
	new_state->PSRCMODE = state->PSRCMODE;
	new_state->SBIT = state->SBIT;
	new_state->ITSTATE = state->ITSTATE;
	new_state->FPSCR = state->FPSCR;

	/* copy the references to the memory */
	new_state->M = state->M;


	return new_state;
}


/**
 * Return a copy of a given state which will be intended for a further simulation,
 * both state will share the same memory
 * and each new state's register will have the same value as in the given state.
 *
 * TODO: we want to be able to simulate on this forked state
 * so we should really care about stack pointer and other address registers
 * used to write data in memory, these should have a different value
 * for each state created as we share the same memory
 *
 * @param	state	the state to fork
 * @return		a fresh allocated copy (to be freed by the caller)
 */
arm_state_t *arm_fork_state(arm_state_t *state)
{
	int i;

	if (state == NULL)
		return NULL;

	/* allocate a new state */
	arm_state_t *new_state = (arm_state_t *)malloc(sizeof(arm_state_t));
	if(new_state == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* copy the platform and lock it */
	new_state->platform = state->platform;
	arm_lock_platform(new_state->platform);

	/* copy all the registers */
	new_state->BBIT = state->BBIT;
	new_state->PBIT = state->PBIT;
	for (i = 0; i < 16; i++)
		new_state->LR_saved[i] = state->LR_saved[i];
	new_state->LBIT = state->LBIT;
	new_state->WBIT = state->WBIT;
	for (i = 0; i < 16; i++)
		new_state->SP_saved[i] = state->SP_saved[i];
	new_state->PSRXMODE = state->PSRXMODE;
	for (i = 0; i < 16; i++)
		new_state->D[i] = state->D[i];
	new_state->MSBIT = state->MSBIT;
	new_state->HBIT = state->HBIT;
	new_state->APSR = state->APSR;
	new_state->SPSR = state->SPSR;
	new_state->NPC = state->NPC;
	new_state->RBIT = state->RBIT;
	new_state->PSRFMODE = state->PSRFMODE;
	for (i = 0; i < 32; i++)
		new_state->S[i] = state->S[i];
	for (i = 0; i < 16; i++)
		new_state->GPR[i] = state->GPR[i];
	new_state->PSRSMODE = state->PSRSMODE;
	for (i = 0; i < 16; i++)
		new_state->SPSR_saved[i] = state->SPSR_saved[i];
	new_state->IBIT = state->IBIT;
	new_state->B15SET = state->B15SET;
	for (i = 0; i < 5; i++)
		new_state->R_saved[i] = state->R_saved[i];
	new_state->UBIT = state->UBIT;
	new_state->PSRCMODE = state->PSRCMODE;
	new_state->SBIT = state->SBIT;
	new_state->ITSTATE = state->ITSTATE;
	new_state->FPSCR = state->FPSCR;

	/* copy the references to the memory */
	new_state->M = state->M;

}


/**
 * Dump all register values of a given state to the given output
 *
 * @param	state	the state whose registers we wish to dump
 * @param	out	the file to dump within, typically stderr or stdout
 */
void arm_dump_state(arm_state_t *state, FILE *out)
{
	int i;

	/* dump all the registers */
	fprintf(out, "BBIT = %02X\n", state->BBIT);
	fprintf(out, "PBIT = %02X\n", state->PBIT);
	fprintf(out, "LR_saved\n");
	for (i = 0; i < 16; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->LR_saved[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "LBIT = %02X\n", state->LBIT);
	fprintf(out, "WBIT = %02X\n", state->WBIT);
	fprintf(out, "SP_saved\n");
	for (i = 0; i < 16; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->SP_saved[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "PSRXMODE = %02X\n", state->PSRXMODE);
	fprintf(out, "D\n");
	for (i = 0; i < 16; i++) {
		fprintf(out, "\t[%d] = %f", i, state->D[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "MSBIT = %02X\n", state->MSBIT);
	fprintf(out, "HBIT = %02X\n", state->HBIT);
	fprintf(out, "APSR = %08X\n", state->APSR);
	fprintf(out, "SPSR = %08X\n", state->SPSR);
	fprintf(out, "NPC = %08X\n", state->NPC);
	fprintf(out, "RBIT = %02X\n", state->RBIT);
	fprintf(out, "PSRFMODE = %02X\n", state->PSRFMODE);
	fprintf(out, "S\n");
	for (i = 0; i < 32; i++) {
		fprintf(out, "\t[%d] = %f", i, state->S[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "GPR\n");
	for (i = 0; i < 16; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->GPR[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "PSRSMODE = %02X\n", state->PSRSMODE);
	fprintf(out, "SPSR_saved\n");
	for (i = 0; i < 16; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->SPSR_saved[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "IBIT = %02X\n", state->IBIT);
	fprintf(out, "B15SET = %02X\n", state->B15SET);
	fprintf(out, "R_saved\n");
	for (i = 0; i < 5; i++) {
		fprintf(out, "\t[%d] = %08X", i, state->R_saved[i]);
		if(i % 4 == 3)
			fputc('\n', out);
	}
	if(i % 4 != 3)
		fputc('\n', out);
	fprintf(out, "UBIT = %02X\n", state->UBIT);
	fprintf(out, "PSRCMODE = %02X\n", state->PSRCMODE);
	fprintf(out, "SBIT = %02X\n", state->SBIT);
	fprintf(out, "ITSTATE = %02X\n", state->ITSTATE);
	fprintf(out, "FPSCR = %08X\n", state->FPSCR);

}


/**
 * return a reference (a pointer in fact) towards the platform of a given state
 *
 * @param	state	the state we want to access the platform
 * @return		the address of the platform of the given state
 */
arm_platform_t *arm_platform(arm_state_t *state)
{
	if (state == NULL)
		return NULL;

	/* return the platform */
	return state->platform;
}


/* simulation functions */


/**
 * Create a new simulator structure with the given state
 * @param	state	the state on which we intend to simulate
 * @param	start_addr	the beginning of the execution (useful for executables compiled with no _start symbol),
 *				if null we leave the PC in its previous state given by the loader
 * @param	exit_addr	the explicitly given last instruction address to simulate, if null we will stop running in another way
 */
arm_sim_t *arm_new_sim(arm_state_t *state, arm_address_t start_addr, arm_address_t exit_addr)
{
	arm_sim_t *sim;

	if (state == NULL)
		return NULL;

	/* allocate a new simulator */
	sim = (arm_sim_t *)malloc(sizeof(arm_sim_t));
	if(sim == NULL)
	{
		errno = ENOMEM;
		return NULL;
	}

	/* link the state to the new simulator */
	sim->state = state;

	/* create a new decoder */
	sim->decoder = arm_new_decoder(arm_platform(state));
	arm_set_cond_state(sim->decoder, state);	if (sim->decoder == NULL)
		return NULL;
	sim->addr_exit = exit_addr;
	if (start_addr)
		sim->state->GPR[15] = start_addr;

	/* not ended at start */
	sim->ended = 0;
	return sim;
}


//======================================================================
#if !defined(ARM_TRACE_CACHE) && !defined(ARM_DTRACE_CACHE)

/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
arm_inst_t *arm_next_inst(arm_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */
	return arm_decode(sim->decoder, sim->state->GPR[15]);
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function arm_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void arm_step(arm_sim_t *sim)
{
	arm_inst_t*  inst;
	arm_state_t* state = sim->state;

	/* retrieving next instruction */
    inst = arm_decode(sim->decoder, state->GPR[15]);

	/* execute it */

	arm_code_table[inst->ident](state, inst);

#ifndef ARM_INF_DECODE_CACHE
#ifndef ARM_FIXED_DECODE_CACHE
#ifndef ARM_LRU_DECODE_CACHE
    /* finally free it */
	arm_free_inst(inst);
#endif
#endif
#endif

	/* ended ? */
	if(sim->addr_exit == state->GPR[15])
		sim->ended = 1;
}


/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t arm_run_and_count_inst(arm_sim_t *sim)
{
	uint64_t i = 0;
    arm_state_t*   state     = sim->state;
    arm_decoder_t* decoder   = sim->decoder;
    arm_address_t  addr_exit = sim->addr_exit;
	arm_inst_t* inst;
	while(!sim->ended) {
		inst = arm_decode(decoder, state->GPR[15]);
		arm_code_table[inst->ident](state, inst);
#ifndef ARM_INF_DECODE_CACHE
#ifndef ARM_FIXED_DECODE_CACHE
#ifndef ARM_LRU_DECODE_CACHE
    /* finally free it */
	arm_free_inst(inst);
#endif
#endif
#endif
		i++;
		if(addr_exit == state->GPR[15])
			sim->ended = 1;
	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void arm_run_sim(arm_sim_t *sim)
{
	arm_state_t*   state     = sim->state;
    arm_decoder_t* decoder   = sim->decoder;
    arm_address_t  addr_exit = sim->addr_exit;
	arm_inst_t* inst;
	while(!sim->ended) {
		inst = arm_decode(decoder, state->GPR[15]);
		arm_code_table[inst->ident](state, inst);
#ifndef ARM_INF_DECODE_CACHE
#ifndef ARM_FIXED_DECODE_CACHE
#ifndef ARM_LRU_DECODE_CACHE
    /* finally free it */
		arm_free_inst(inst);
#endif
#endif
#endif
		if(addr_exit == state->GPR[15])
			sim->ended = 1;
	}
}
#endif
//======================================================================
#ifdef ARM_TRACE_CACHE
/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
arm_inst_t *arm_next_inst(arm_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */
	return arm_decode(sim->decoder, sim->state->GPR[15]) + ((sim->state->NIA >> 2) & (TRACE_DEPTH-1));
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function arm_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void arm_step(arm_sim_t *sim)
{
	arm_inst_t*  inst;
	arm_state_t* state = sim->state;

	/* retrieving next instruction */
    inst =  arm_decode(sim->decoder, state->GPR[15]) + ((sim->state->NIA >> 2) & (TRACE_DEPTH-1));

	/* execute it */

	arm_code_table[inst->ident](state, inst);

	/* ended ? */
	if(sim->addr_exit == state->GPR[15])
		sim->ended = 1;
}


/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t arm_run_and_count_inst(arm_sim_t *sim)
{
	uint64_t i = 0;
    uint32_t num_bloc;
    arm_state_t*   state     = sim->state;
    arm_decoder_t* decoder   = sim->decoder;
    arm_address_t  addr_exit = sim->addr_exit;
    arm_inst_t*    inst, *trace;

	while(!sim->ended)
	{
        trace    = arm_decode(decoder, state->GPR[15]);
        num_bloc = (state->GPR[15] >> 2) >> TRACE_DEPTH_PW;

        while((((state->GPR[15] >> 2)>> TRACE_DEPTH_PW) == num_bloc) && (!sim->ended) && (addr_exit != state->GPR[15]))
        {
			inst = trace + ((state->NIA >> 2) & (TRACE_DEPTH-1));
            			}
			i++;
		}

		/* ended ? */
		if(addr_exit == state->GPR[15])
			sim->ended = 1;
	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void arm_run_sim(arm_sim_t *sim)
{
    uint32_t num_bloc;
    arm_state_t*   state     = sim->state;
    arm_decoder_t* decoder   = sim->decoder;
    arm_address_t  addr_exit = sim->addr_exit;
    arm_inst_t*    inst, *trace;

	while(addr_exit != state->GPR[15])
	{
        trace    = arm_decode(decoder, state->GPR[15]);
        num_bloc = (state->GPR[15] >> 2) >> TRACE_DEPTH_PW;

        while((((state->GPR[15] >> 2)>> TRACE_DEPTH_PW) == num_bloc) && (addr_exit != state->GPR[15]))
        {
			inst = trace + ((state->NIA >> 2) & (TRACE_DEPTH-1));
            		    arm_code_table[inst->ident](state, inst);
        }
	}
}
#endif
//======================================================================
#ifdef ARM_DTRACE_CACHE
/**
 * Return the next instruction to be executed by the given simulator
 *
 * this instruction is pointed by the PC
 *
 * @param	sim	the simulator which we simulate within
 * @return		the next instruction to be executed, fully decoded
 */
arm_inst_t *arm_next_inst(arm_sim_t *sim)
{
	/* retrieving the instruction (which is allocated by the decoder) */
	/* we let the caller check for error */

	/* Static variable is an optimisation hack
	 * in order to cache the current trace */
	static arm_inst_t*  inst = 0;
	arm_state_t* state = sim->state;

	/* retrieving next instruction */
	if(inst != 0)
	{
		inst++;
		if(inst->ident == -1)
			inst =  arm_decode(sim->decoder, state->GPR[15]);
	}else
	{
		inst =  arm_decode(sim->decoder, state->GPR[15]);
	}
	return inst;
}


/**
 * Execute the next instruction in the given simulator.
 * It doesn't check if we reached the last instruction, so it should be done
 * separately using the function arm_is_sim_ended
 * @param	sim	the simulator which we simulate within
 */
void arm_step(arm_sim_t *sim)
{
	/* Static variable is an optimisation hack
	 * in order to cache the current trace */
	static arm_inst_t*  inst = 0;
	arm_state_t* state = sim->state;

	/* retrieving next instruction */
	if(inst != 0)
	{
		inst++;
		if(inst->ident == -1)
			inst =  arm_decode(sim->decoder, state->GPR[15]);
	}else
	{
		inst =  arm_decode(sim->decoder, state->GPR[15]);
	}


	/* execute it */

	arm_code_table[inst->ident](state, inst);

		if(sim->addr_exit == state->GPR[15])
			sim->ended = 1;
}


/**
 * Straightforward execution of the simulated programm.
 * It runs and count the number of executed instructions
 * until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * @return number of executed instructions
 * */
uint64_t arm_run_and_count_inst(arm_sim_t *sim)
{
	uint64_t i = 0;
    arm_state_t*   state     = sim->state;
    arm_decoder_t* decoder   = sim->decoder;
    arm_address_t  addr_exit = sim->addr_exit;
    arm_inst_t*    inst;

	while(!sim->ended)
	{
        inst = arm_decode(decoder, state->GPR[15]);

        while( (inst->ident != -1) && (!sim->ended) && (addr_exit != state->GPR[15]))
        {
            		    arm_code_table[inst->ident](state, inst);
			inst++;
			i++;
        }

        /* ended ? */
		if(addr_exit == state->GPR[15])
			sim->ended = 1;

	}
	return i;
}

/**
 * Straightforward execution of the simulated programm.
 * It runs until the programm reached the last instruction.
 * this is the <bold> fastest </bold> way to simulate a programm
 * @param	sim	the simulator which we simulate within
 * */
void arm_run_sim(arm_sim_t *sim)
{
    uint32_t num_bloc;
    arm_state_t*   state     = sim->state;
    arm_decoder_t* decoder   = sim->decoder;
    arm_address_t  addr_exit = sim->addr_exit;
    arm_inst_t*    inst;

	while(!sim->ended)
	{
        inst = arm_decode(decoder, state->GPR[15]);

        while( (inst->ident != -1) && (addr_exit != state->GPR[15]))
        {
            		    arm_code_table[inst->ident](state, inst);
			inst++;
        }

        /* ended ? */
		if(addr_exit == state->GPR[15])
			sim->ended = 1;
	}
}

#endif
//======================================================================
/**
 * @fn int arm_is_sim_ended(arm_sim_t *sim);
 * Indicate if the simulation is finished on the given simulator
 * @param	sim	the simulator which we simulate within
 * @return	whether or not the simulation is ended (0 => false, anything!=0 => true)
 */

/**
 * destruction of a simulator object, the associated state and decoder are also destroyed
 * @param	sim	the simulator to be deleted
 */
void arm_delete_sim(arm_sim_t *sim)
{
	if (sim == NULL)
		return;

	/* delete the decoder */
	arm_delete_decoder(sim->decoder);

	/* delete the state */
	arm_delete_state(sim->state);

	/* delete the sim */
	free(sim);
}


/**
 * Get the address of the next instruction to be executed,
 * indicated by PC
 * @param sim	Simulator to work with.
 * @return		Address of the current instruction.
 */
arm_address_t  arm_next_addr(arm_sim_t *sim) {
	assert(sim);
	return sim->state->GPR[15];
}


/**
 * Set the address of the next instruction.
 * @param sim		Current simulator.
 * @param address	Next address.
 */
void arm_set_next_address(arm_sim_t *sim, arm_address_t address) {
	assert(sim);
	sim->state->GPR[15] = address;
}


/**
 * Set the exit address for simulation.
 * @param sim		Current simulator.
 * @param address	Exit address.
 */
void arm_set_exit_address(arm_sim_t *sim, arm_address_t address) {
	sim->addr_exit = address;
}


/**
 * Null-name ended list, provides the list of available decoding modes.
 */
arm_mode_t arm_modes[] = {
	{ "ARM", arm_decode_ARM },	{ "THUMB", arm_decode_THUMB },
	{ 0, 0 }
};
