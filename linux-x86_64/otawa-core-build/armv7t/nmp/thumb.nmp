////////////////////////////////////////////////////////////////////
//
//	Description of  thumb instructions for ARM Processor in Sim-nML
//
//                See file arm.nmp
//*************************************************************************//
//  date            : July 2006                                            //
//  copyright       : Institut de Recherche en Informatique de Toulouse    //
//  author          : Tahiry RATSIAMBAHOTRA                                //
//  email           : ratsiam@irit.fr, sainrat@irit.fr                     //
//*************************************************************************//

//*************************************************************************//
//                                                                         //
//  This program is free software; you can redistribute it and/or modify   //
//  it under the terms of the GNU General Public License as published by   //
//  the Free Software Foundation; either version 2 of the License, or      //
//  (at your option) any later version.                                    //
//                                                                         //
//*************************************************************************//

canon "//no_collect_regs"()
canon "swi_impl"(card(32))

// From Jerabek
canon u8 "f_set_ITSTATE"(u8)
canon u8 "f_get_ITSTATE"()
canon u8 "f_get_update_ITSTATE"()

let UNPREDICTABLE =0b11111111111111111111111111111111

mode IMM3(n: u3) = n
	syntax = format("#%d", n)
	image  = format("%3b", n)

mode IMM5 (n : u5) = n
	syntax = format("#%d", n)
	image  = format("%5b", n)

mode IMM7(n: u7) = n
	syntax = format("#%d", n)
	image  = format("%7b", n)

mode IMM8(n: u8) = n
	syntax = format("#%d", n)
	image  = format("%8b", n)

mode SIMM8(n: s8) = n
	syntax = format("#%d", n)
	image  = format("%8b", n)

mode SIMM11(n: s11) = n
	syntax = format("#%d", n)
	image  = format("%11b", n)

mode setR_Ton()=1
	syntax = ""
	image = "1"


mode setR_Toff()=0
	syntax = ""
	image = "0"


mode setR_T = setR_Ton | setR_Toff

//////////////////////////////////////////
// mode for 11bits offset
//////////////////////////////////////////
mode OFFS11(n: u11) = n
	syntax = format ("%d", n)
	image  = format ("%11b", n)


mode REG_THUMB_INDEX(ro: card(3)) = ro
	syntax = format("r%d", ro)
	hsyntax =
		switch(ro) {
		case 0: "r8"
		case 1: "r9"
		case 2: "sl"
		case 3: "fp"
		case 4: "ip"
		case 5: "sp"
		case 6: "lr"
		case 7: "pc"
	}
	image  = format("%3b", ro)


macro first_bit_on8(v8) = \
	if v8<0..0> == 1 then 7 else \
	if v8<1..1> == 1 then 6 else \
	if v8<2..2> == 1 then 5 else \
	if v8<3..3> == 1 then 4 else \
	if v8<4..4> == 1 then 3 else \
	if v8<5..5> == 1 then 2 else \
	if v8<6..6> == 1 then 1 else \
	if v8<7..7> == 1 then 0 else \
	-1 endif endif endif endif endif endif endif endif \

macro syntax_thumb_reg(on_off, num_reg) = \
	if on_off == 1 then \
		format("r%d", num_reg) \
	else \
		"" \
	endif \

macro syntax_thumb_reg_format(idx, v8) = \
	format("%s%s", if v8<idx..idx> == 0 then "" else ", " endif, syntax_thumb_reg(v8<idx..idx>, idx)) \

mode THUMB_REG_LIST(r: u8) = r
	image  = format( "%8b", r)
	start = first_bit_on8(r)
	syntax = if start == -1 then "" else
		format("%s%s%s%s%s%s%s%s",
			syntax_reg_format(0, r),
			syntax_reg_format(1, r),
			syntax_reg_format(2, r),
			syntax_reg_format(3, r),
			syntax_reg_format(4, r),
			syntax_reg_format(5, r),
			syntax_reg_format(6, r),
			syntax_reg_format(7, r)
		) endif


// r should be a REG_THUMB_INDEX (from 0 to 7 only)
macro Get_THUMB_GPR(r) = GPR[r]


///////////////////////////////////////////
// All thumb Instructions
///////////////////////////////////////////

op THUMB(i: thumb)
	image = i.image
	syntax = i.syntax
	action = { i.action; }
	instruction_set_select = TFLAG == 1
	instruction_set_name = "THUMB"

op thumb =  thumb1 | thumb2

op thumb1(x: thumb1_list)
	image = x.image
	syntax = x.syntax
	action = {
		"//no_collect_regs"();
		NPC = PC + 2;
		PC = PC + 4;
		if ConditionPassed then
			"//do_collect_regs"();
			x.action;
		endif;
		if InITBlock then
			ITAdvance;
		endif;
		PC = NPC;
	}

op thumb1_list =
	  ADD_thumb | AND_thumb | ASR_thumb
	| B_thumb | B_thumb_T2 | BIC_thumb | BKPT_thumb
	| BLX_thumb | BX_thumb | CBNZ_CBZ_thumb| COMPARE_thumb | EOR_thumb | LDMIA_thumb
	| LDR_thumb | LDRB_thumb | LDRH_thumb | LDRS_thumb | LSL_thumb
	| LSR_thumb | MUL_thumb | MVN_thumb | NEG_thumb
	| ORR_thumb | POP_thumb | PUSH_thumb | REV_thumb | REV16_thumb | REVSH_thumb
	| ROR_thumb | SBC_thumb
	| STMIA_thumb | STR_thumb | STRB_thumb | STRH_thumb | SUB_thumb
	| SXTB_thumb | SXTH_thumb
	| TST_thumb  |  MOV_thumb //| NOP_thumb // Shadowed by the work from Jerabek
	| NOP_thumb_jer | UXTB_thumb | UXTH_thumb


///////////////////////////////////////////
// I Arithmetic Instructions
///////////////////////////////////////////


op ADD_thumb = ADC_thumb | ADD_imm1_thumb | ADD_imm2_thumb | ADD_imm3_thumb
| ADD_imm4_thumb | ADD_imm5_thumb | ADD_reg1_thumb| ADD_reg2_thumb



op ADC_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("adc%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rn.syntax)
	image = format("0100000101%s%s", rn.image, rd.image)
	action = {
		TMP_REG1 = Get_THUMB_GPR(rd);
		TMP_REG2 = Get_THUMB_GPR(rn);
		TMP_SWORD = TMP_REG2 + TMP_REG1 + CFLAG;
		GPR[rd] = TMP_SWORD;
		CFLAG =  CarryFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		VFLAG = OverflowFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		TMP_REG1 = Get_THUMB_GPR(rd);
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}

op ADD_imm1_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm:IMM3)
	ITCOND = "f_get_update_ITSTATE"()
	syntax =
		if imm == 0 then
			format("mov%s %s, %s", op_cond_syntax_16(ITCOND),  rd.syntax, rn.syntax)
		else
			format("add%s %s, %s, %s", op_cond_syntax_16(ITCOND),  rd.syntax, rn.syntax, imm.syntax)
		endif
	image = format("0001110%s%s%s", imm.image, rn.image, rd.image)
	action = {
		TMP_REG2 = Get_THUMB_GPR(rn);
		TMP_SWORD = TMP_REG2 + imm;
		GPR[rd] = TMP_SWORD;
		CFLAG = CarryFromAdd(TMP_REG2,imm,TMP_SWORD);
		VFLAG = OverflowFromAdd(TMP_REG2,imm,TMP_SWORD);
		NFLAG = TMP_SWORD<31..31>;
		if TMP_SWORD == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}

op ADD_imm2_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("add%s %s, %s", op_cond_syntax_16(ITCOND),  rd.syntax,imm.syntax)
	image = format("00110%s%s", rd.image, imm.image)
	setflags = !InITBlock()
	imm32 = ZeroExtend(imm, 32)
	action = {
		AddWithCarry(result, carry, overflow, R[rd], imm32, 0);
		R[rd] = result;
		if setflags then
			APSR_N = result<31..31>;
			APSR_Z = result == 0;
			APSR_C = carry;
			APSR_V = overflow;
		endif;
	}

op ADD_reg1_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("add%s %s, %s, %s", op_cond_syntax_16(ITCOND),  rd.syntax, rn.syntax, rm.syntax)
	image = format("0001100%s%s%s", rm.image, rn.image, rd.image)
	action = {
		TMP_REG1 = Get_THUMB_GPR(rm);
		TMP_REG2 = Get_THUMB_GPR(rn);
		TMP_SWORD = TMP_REG2 + TMP_REG1;
		GPR[rd] = TMP_SWORD;
		CFLAG =  CarryFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		VFLAG = OverflowFromAdd(TMP_REG2,TMP_REG1,TMP_SWORD);
		TMP_REG1 = Get_THUMB_GPR(rd);
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}

op ADD_reg2_thumb( rd : REG_INDEX, rm: REG_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("add%s %s, %s", op_cond_syntax_new(ITCOND),  rd.syntax, rm.syntax)
	image = format("01000100%1b%s%3b", rd.number<3..3>, rm.image, rd.number<2..0>)
	action = {
		TMP_REG1 = Get_ARM_GPR(rm);
		TMP_REG2 = Get_ARM_GPR(rd);
		Set_ARM_GPR(rd, TMP_REG2 + TMP_REG1);
	}

op ADD_imm3_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("add%s %s, pc, %s", op_cond_syntax_new(ITCOND),  rd.syntax,imm.syntax)
	image = format("10100%s%s", rd.image, imm.image)
	action = {
		GPR[rd] = ((__IADDR + 4) & 0xfffffffc) + (coerce(u32, imm) << 2);
	}

// ADD SP plus immediate
op ADD_imm4_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("add%s %s, sp, %s", op_cond_syntax_new(ITCOND),  rd.syntax,imm.syntax)
	image = format("10101%s%s", rd.image, imm.image)
	action = {
		GPR[rd] = Get_ARM_GPR(13) + (coerce(u32, imm) << 2);
	}

// ADD SP plus immediate
op ADD_imm5_thumb( imm: IMM7)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("add%s sp, sp, #%d", op_cond_syntax_new(ITCOND),  imm * 4)
	image = format("101100000%s", imm.image)
	action = {
		Set_ARM_GPR(13, Get_ARM_GPR(13) + (coerce(u32, imm) << 2));
	}

op AND_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("and%s %s, %s", op_cond_syntax_16(ITCOND),  rd.syntax, rm.syntax)
	image = format("0100000000%s%s", rm.image, rd.image)
	action = {
		TMP_REG1 = GPR[rd] & GPR[rm];
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd] = TMP_REG1;
	}

op ASR_thumb = ASR1_thumb | ASR2_thumb

op ASR1_thumb(rd : REG_THUMB_INDEX, rm:REG_THUMB_INDEX, imm : IMM5 )
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("asr%s %s, %s, %s", op_cond_syntax_16(ITCOND),  rd.syntax, rm.syntax, imm.syntax)
	image = format("00010%s%s%s", imm.image, rm.image,rd.image)
	action = {
		TMP_REG1 = GPR[rm];
		if imm == 0 then
			TMP_BIT = TMP_REG1<31..31>;
			if  TMP_BIT == 0 then
				TMP_REG2 = 0;
			else
				TMP_REG2 = 0b11111111111111111111111111111111;
			endif;
		else
			ASR_C(TMP_REG1, imm, TMP_REG2, CFLAG);
		endif;
		NFLAG = TMP_REG2<31..31>;
		ZFLAG = TMP_REG2 == 0;
		GPR[rd] = TMP_REG2;
	}

op ASR2_thumb(rd : REG_THUMB_INDEX, rs:REG_THUMB_INDEX )
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("asr%s %s, %s", op_cond_syntax_16(ITCOND),  rd.syntax, rs.syntax)
	image = format("0100000100%s%s", rs.image,rd.image)
	action = {
		TMP_IMM = GPR[rs]<7..0>;
		TMP_REG1 = GPR[rd];
		if TMP_IMM == 0 then
		else if TMP_IMM < 32 then
			TMP_IMM2 = TMP_IMM - 1;
			CFLAG = GPR[rd]<TMP_IMM2..TMP_IMM2>;
			GPR[rd] = TMP_REG1 >> TMP_IMM;
		else
			CFLAG = TMP_REG1<31..31>;
			if CFLAG == 0 then
				GPR[rd] = 0;
			else
				GPR[rd] =	UNPREDICTABLE;
			endif;
		endif; endif;
		NFLAG = GPR[rd]<31..31>;
		if GPR[rd] == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}



// ****** branch instructions ******

op B_thumb(cond: u4,  simm: SIMM8)
	ITCOND = "f_get_update_ITSTATE"()
	target = __IADDR + 4 + (coerce(s32, simm) << 1)
	syntax_cond =
		switch (cond)  {
		case 0: "beq"
		case 1: "bne"
		case 2: "bcs"
		case 3: "bcc"
		case 4: "bmi"
		case 5: "bpl"
		case 6: "bvs"
		case 7: "bvc"
		case 8: "bhi"
		case 9: "bls"
		case 10: "bge"
		case 11: "blt"
		case 12: "bgt"
		case 13: "ble"
		case 14: "b"
		case 15: "svc"
		}
	syntax = if(cond == 15) then
			format("%s%s %d", syntax_cond, op_cond_syntax_new(ITCOND), coerce(u8, simm))
		else
			format("%s.n %08x", syntax_cond, target)
		endif
	image = format("1101%4b%s", cond, simm.image)
	action = {
		if (cond == 15 ) then
			"swi_impl"(simm);
		else
			if (calcul_condition(cond)) then
				TMP_REG1 = __IADDR + 4;
				TMP_IMM = coerce(s32, simm) << 1;
				TMP_REG2 = TMP_REG1 + TMP_IMM;
				NPC = TMP_REG2;
			endif;
		endif;
	}

op B_thumb_T2(imm11: int(11))
	ITCOND = "f_get_update_ITSTATE"()
	target = __IADDR + 4 + SignExtend(imm11 :: 0<0..0>, 32)
	syntax = format("b%s.n %l", op_cond_syntax_16(ITCOND), target)
	image = format("11100 %11b", imm11)
	action = {
		// if InITBlock && !LastInITBlock then UNPREDICTABLE
		BranchWritePC_thumb(target);
	}


op BIC_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("bic%s %s, %s", op_cond_syntax_16(ITCOND),rd.syntax, rm.syntax)
	image = format("0100001110%s%s", rm.image, rd.image)
	action = {
		TMP_REG1 = GPR[rd];
		GPR[rd] = TMP_REG1 & TMP_REG2;
		NFLAG = GPR[rd]<31..31>;
		TMP_REG1 = GPR[rd];
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}

op BKPT_thumb(imm: IMM8)
	ITCOND = 0
	syntax = format("bkpt %s",imm.syntax)
	image = format("10111110%s", imm.image)
	action = {
	}

op BLX_thumb = /*BLX1_thumb |*/ BLX2_thumb

/*op BLX1_thumb(H : u2, offs :OFFS11)
	target = __IADDR + 4 + (coerce(s32, offs) << 1)
	syntax =
		switch(H) {
		case 0b00: format("b %08x", target)
		case 0b01: format("blx lr, #%08x", (coerce(s32, offs) << 1) & 0xfffffffc)
		case 0b10: format("add lr, pc, #%d", coerce(s32, offs) << 12)
		case 0b11: format("bl lr, #%08x", (coerce(s32, offs) << 1))
		}
	image  = format("111%2b%s", H, offs.image)
	action = {
		switch(H) {
		case 0b00:
			NPC = target;
		case 0b01:
			Set_ARM_GPR(15, (Get_ARM_GPR(14) + (coerce(u32, offs) << 1)) & 0xfffffffc);
			Set_ARM_GPR(14 , (__IADDR + 2) | 1);
			TBIT = 0;
		case 0b10:
			Set_ARM_GPR(14, __IADDR + 4 +(coerce(s32, offs) << 12));
		case 0b11:
			NPC = Get_ARM_GPR(14) + (coerce(u32, offs) << 1);
			Set_ARM_GPR(14, (__IADDR + 2) | 1);
		};
}*/


op BLX2_thumb(rm: REG_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("blx%s %s", op_cond_syntax_new(ITCOND), rm.syntax)
	image  = format("010001111%s000",rm.image)
	action = {
		Set_ARM_GPR(14, (__IADDR + 2) | 1);
		TMP_REG1 = Get_ARM_GPR(rm);
		TFLAG = TMP_REG1<0..0>;
		NPC = TMP_REG1 & 0xfffffffe;
	}


op BX_thumb(rm: REG_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("bx%s %s", op_cond_syntax_new(ITCOND), rm.syntax)
	image  = format("010001 11 0 %s 000", rm.image)
	target = __IADDR + 2
	// TODO! Write correct target here!!!
	action = {
		TMP_REG1 = Get_ARM_GPR(rm);
		TFLAG = TMP_REG1<0..0>;
		NPC = coerce(u32, TMP_REG1<31..1>) << 1;
	}


op CBNZ_CBZ_thumb(rn: REG_THUMB_INDEX, i: card(1), imm5: card(5), op_: card(1))
	ITCOND = "f_get_update_ITSTATE"()
	imm32 = ZeroExtend(i :: imm5 :: 0b0, 7)
	target = __IADDR + 4 + imm32
	syntax = if(op_ == 0b1) then
			format("cbnz%s %s, %d", op_cond_syntax_new(ITCOND), rn.syntax, imm32)
		else
			format("cbz%s %s, %d", op_cond_syntax_new(ITCOND), rn.syntax, imm32)
		endif
	image = format("1011 %1b 0 %1b 1 %5b %s", op_, i, imm5, rn)
	nonzero = op_
	//if InITBlock() then UNPREDICTABLE;
	action = {
		//EncodingSpecificOperations();
		if nonzero ^ (R[rn] == 0) then
			BranchWritePC(PC + imm32);
		endif;
	}


op COMPARE_thumb = CMN_shr_thumb | CMP_imm_thumb | CMP_shr1_thumb
				 | CMP_shr2_thumb

op CMN_shr_thumb(rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("cmn%s %s, %s", op_cond_syntax_new(ITCOND), rn.syntax, rm.syntax)
	image = format("0100001011%s%s", rm.image,  rn.image)
	action= {
		TMP_REG1 = GPR[rn];
		TMP_REG2 = GPR[rm];
		Temp = TMP_REG1 + TMP_REG2;
		NFLAG = Temp<31..31>;
		if Temp == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		CFLAG =  CarryFromAdd(TMP_REG1,TMP_REG2,Temp);
		VFLAG =  OverflowFromAdd(TMP_REG1,TMP_REG2,Temp);
	}


op CMP_imm_thumb(rn : REG_THUMB_INDEX, imm : IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("cmp%s %s, %s", op_cond_syntax_new(ITCOND), rn.syntax, imm.syntax)
	image = format("00101%s%s", rn.image, imm.image)
	action = {
		AddWithCarry(result, CFLAG, VFLAG, GPR[rn], ~ZeroExtend(imm, 32), 1);
		NFLAG = result<31..31>;
		ZFLAG = result == 0;
	}

op CMP_shr1_thumb(rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("cmp%s %s, %s", op_cond_syntax_new(ITCOND), rn.syntax, rm.syntax )
	image = format("0100001010%s%s", rm.image,  rn.image)
	action = {
		AddWithCarry(result, CFLAG, VFLAG, GPR[rn], ~GPR[rm], 1);
		NFLAG = result<31..31>;
		ZFLAG = result == 0;
	}

op CMP_shr2_thumb(H: u1, rn : REG_THUMB_INDEX, rm : REG_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("cmp%s %s, %s", op_cond_syntax_new(ITCOND), rn.syntax, rm.syntax )
	image = format("01000101%1b%s%s", H, rm.image,  rn.image)
	action = {
		TMP_REG1 = Get_ARM_GPR(rn + if H == 1 then 8 else 0 endif);
		TMP_REG2 = Get_ARM_GPR(rm);
		AddWithCarry(result, CFLAG, VFLAG, TMP_REG1, ~TMP_REG2, 1);
		NFLAG = result<31..31>;
		ZFLAG = result == 0;
	}

op EOR_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("eor%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rm.syntax)
	image = format("0100000001%s%s", rm.image, rd.image)
	action = {
		TMP_REG1 = GPR[rd];
		TMP_REG2 = GPR[rm];
		TMP_SWORD = TMP_REG2 ^ TMP_REG1;
		NFLAG = TMP_SWORD<31..31>;
		if TMP_SWORD == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd] = TMP_SWORD;
	}

op LDMIA_thumb(rn: REG_THUMB_INDEX, llist: THUMB_REG_LIST)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldmia%s %s, {%s}", op_cond_syntax_new(ITCOND), rn.syntax, llist.syntax)
	image = format("11001%s%s", rn.image, llist.image)
	action = {
		// Compute number of set bits in the register list to compute the start address
		TMP_REGLIST = llist;
		TMP_IMM  = 0;
		TMP_SETBIT = 0;
		B15SET = 0;
		number_of_set_bits_in;

		TMP_REGLIST = llist;
		TMP_REG1 = GPR[rn];
		GPR[rn] = TMP_REG1 + TMP_SETBIT * 4;
		TMP_START_ADDR = TMP_REG1;
		TMP_END_ADDR = TMP_REG1 + (TMP_SETBIT * 4) - 4;
		TMP_IMM = 0;
		boucle;

		//Note that the assert mode is not implemented, programmer may take
		//		  care of the address in paramater !
	}

	number_of_set_bits_in = {
		//Count the amount of bits into the list
		if (TMP_IMM != 8) then
			if (TMP_REGLIST & 1 == 1) then
				TMP_SETBIT = TMP_SETBIT + 1;
				if (TMP_IMM == 7) then
					B15SET = 1;
				endif;
			endif;
			TMP_REGLIST = TMP_REGLIST >> 1;
			TMP_IMM = TMP_IMM + 1;
			number_of_set_bits_in;
		endif;
	}

    boucle = {
		if (TMP_IMM != 8) then
			if (TMP_REGLIST & 1 == 1) then
				GPR[TMP_IMM] = M32[TMP_START_ADDR];
				TMP_START_ADDR = TMP_START_ADDR + 4;
			endif;
			TMP_REGLIST = TMP_REGLIST >> 1;
			TMP_IMM = TMP_IMM + 1;
			boucle;
		endif;
	}

op LDR_thumb = LDR_imm_thumb | LDR_shr_thumb | LDR_imm2_thumb| LDR_imm3_thumb

op LDR_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldr%s %s, [%s, #0x%x]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, imm*4)
	image = format("01101%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm * 4;
		 if ((TMP_START_ADDR & 3 ) == 0) then
                      TMP_REG1 = M32[TMP_START_ADDR];
                 else
                    TMP_REG1 = UNPREDICTABLE;
                  endif;
                 GPR[rd] = TMP_REG1;

                 }

op LDR_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldr%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0101100%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 if ((TMP_START_ADDR & 3 ) == 0) then
                      TMP_REG1 = M32[TMP_START_ADDR];
                 else
                    TMP_REG1 = UNPREDICTABLE;
                  endif;
                 GPR[rd] = TMP_REG1;

                 }

// LDR (literal) T1 in arm7
op LDR_imm2_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldr%s %s, [pc, #0x%x]", op_cond_syntax_new(ITCOND), rd.syntax, imm*4)
	image = format("01001%s%s", rd.image, imm.image)
	action = {
		TMP_START_ADDR = Align(PC, 4) + coerce(u32, imm::0b00);
		GPR[rd] = M32[TMP_START_ADDR];
	}

op LDR_imm3_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldr%s %s, [sp, #0x%x]", op_cond_syntax_new(ITCOND), rd.syntax, imm*4)
	image = format("10011%s%s", rd.image, imm.image)
	action = {
		 TMP_START_ADDR = Get_ARM_GPR(13) + (coerce(u32, imm) << 2);
                 if ((TMP_START_ADDR & 3 ) == 0) then
                      TMP_REG1 = M32[TMP_START_ADDR];
                 else
                    TMP_REG1 = UNPREDICTABLE;
                  endif;
                 GPR[rd] = TMP_REG1;

                 }


op LDRB_thumb = LDRB_imm_thumb | LDRB_shr_thumb

op LDRB_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldrb%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, imm.syntax)
	image = format("01111%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm ;
		 TMP_IMM = M[TMP_START_ADDR];
                 GPR[rd] = TMP_IMM;

                 }

op LDRB_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldrb%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0101110%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_IMM = M[TMP_START_ADDR];
                 GPR[rd] = TMP_IMM;

                 }


op LDRH_thumb = LDRH_imm_thumb | LDRH_shr_thumb

op LDRH_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldrh%s %s, [%s, #0x%x]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, imm*2)
	image = format("10001%s%s%s", imm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + imm * 2;
		 TMP_REGLIST = M16[TMP_START_ADDR];
                 GPR[rd] = TMP_REGLIST;

                 }


op LDRH_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldrh%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0101101%s%s%s", rm.image, rn.image, rd.image)
	action = {
		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_BIT = TMP_START_ADDR<0..0>;
                 if (TMP_BIT == 0) then
                      TMP_REGLIST = M16[TMP_START_ADDR];
                 else
                    TMP_REGLIST = UNPREDICTABLE;
                  endif;
		 GPR[rd] = TMP_REGLIST;

                 }

op LDRS_thumb = LDRSB_thumb | LDRSH_thumb

op LDRSB_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldrsb%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0101011%s%s%s", rm.image, rn.image, rd.image)
	action = {

		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_IMM = M[TMP_START_ADDR];
		 TMP_BIT = TMP_IMM<7..7>;
		 if (TMP_BIT == 1) then
		    TMP_REG1 = UNPREDICTABLE;
		    TMP_REG1 = TMP_REG1 << 8;
		    TMP_REG2 = TMP_REG1 + TMP_IMM;
		  else
			TMP_REG2 = TMP_IMM;
	          endif;
                 GPR[rd] = TMP_REG2;

                 }

op LDRSH_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ldrsh%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0101111%s%s%s", rm.image, rn.image, rd.image)
	action = {

		 TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		 TMP_BIT = TMP_START_ADDR<0..0>;
                 if (TMP_BIT == 0) then
		  		TMP_REGLIST = M16[TMP_START_ADDR];
				TMP_BIT = TMP_REGLIST<15..15>;
				if (TMP_BIT == 1) then
				   TMP_REG1 = UNPREDICTABLE;
				   TMP_REG1 = TMP_REG1 << 16;
				   TMP_REG2 = TMP_REG1 + TMP_REGLIST;
				else
					TMP_REG2 = TMP_REGLIST;
	                        endif;
		       else
	        	        TMP_REG2 = UNPREDICTABLE;
	          endif;
                 GPR[rd] = TMP_REG2;

                 }

op LSL_thumb = LSL_imm_thumb | LSL_shr_thumb

op LSL_imm_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX, imm: IMM5)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("lsl%s %s, %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rm.syntax, imm.syntax)
	image = format("00000%s%s%s", imm.image, rm.image, rd.image)
	action = {
		if(imm == 0) then
			TMP_REG1 = GPR[rm];
		else
			TMP_IMM = 32 - imm;
			CFLAG = GPR[rm]<TMP_IMM..TMP_IMM>;
			TMP_REG1 = GPR[rm] << imm;
		endif;
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd]= TMP_REG1;
	}

op LSL_shr_thumb( rd : REG_THUMB_INDEX, rs : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("lsl%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rs.syntax)
	image = format("0100000010%s%s", rs.image, rd.image)
	action = {
		TMP_IMM = GPR[rs]<7..0>;
		TMP_REG1 = GPR[rd];
		if (TMP_IMM == 0) then
		else if (TMP_IMM < 32) then
			TMP_IMM2 = 32 - TMP_IMM;
			CFLAG = TMP_REG1<TMP_IMM2..TMP_IMM2>;
			TMP_REG1 = TMP_REG1 << TMP_IMM;
		else if (TMP_IMM == 32)  then
			CFLAG = TMP_REG1<0..0>;
			TMP_REG1 = 0;
		else if (TMP_IMM > 32)  then
			CFLAG = 0;
			TMP_REG1 = 0;
		endif; endif; endif; endif;
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd]= TMP_REG1;
	}

op LSR_thumb = LSR_imm_thumb | LSR_shr_thumb

op LSR_imm_thumb(rd: REG_THUMB_INDEX, rm: REG_THUMB_INDEX, imm5: IMM5)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("lsr%s %s, %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rm.syntax, imm5.syntax)
	image = format("00001%s%s%s", imm5.image, rm.image, rd.image)
	setflags = !ITCOND
	d = UInt(rd)
	m = UInt(rm)
	setflags = !InITBlock()
	shift_n = if imm5 == 0 then 32 else imm5 endif
	action = {
		if ConditionPassed() then
			result = R[m] >> shift_n;
			if setflags then
				APSR_N = result<31..31>;
				APSR_Z = IsZeroBit(result);
				APSR_C = R[m]<(shift_n - 1)..(shift_n - 1)>;
				// APSR.V unchanged
			endif;
			R[d] = result;
		endif;
}

op LSR_shr_thumb( rd : REG_THUMB_INDEX, rs : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("lsr%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rs.syntax)
	image = format("0100000011%s%s", rs.image, rd.image)
	action = {
		TMP_IMM = GPR[rs]<7..0>;
		TMP_REG1 = GPR[rd];
		if (TMP_IMM == 0) then
		else if (TMP_IMM < 32) then
			TMP_IMM2 =  TMP_IMM - 1;
			CFLAG = TMP_REG1<TMP_IMM2..TMP_IMM2>;
			TMP_REG1 = TMP_REG1 >> TMP_IMM;
		else if (TMP_IMM == 32)  then
			CFLAG = TMP_REG1<31..31>;
			TMP_REG1 = 0;
		else if (TMP_IMM > 32)  then
			CFLAG = 0;
			TMP_REG1 = 0;
		endif; endif; endif; endif;
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd]= TMP_REG1;
	}

op MOV_thumb = MOV_imm_thumb | MOV_shr2_thumb

op MOV_imm_thumb(rd : REG_THUMB_INDEX, imm : IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("mov%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, imm.syntax)
	image = format("00100%s%s", rd.image, imm.image)
	setflags = !InITBlock()
	action = {
		GPR[rd] = imm;
		if setflags then
			APSR_N = imm<31..31>;
			APSR_Z = imm == 0;
		endif;
	}

op MOV_shr_thumb(rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("mov%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rn.syntax)
	image = format("0001110000%s%s", rn.image, rd.image)
	action = {
		TMP_REG1 = GPR[rn];
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd] = TMP_REG1;
	}

op MOV_shr2_thumb(H: u1, rd: REG_THUMB_INDEX, rm: REG_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("mov%s %s, %s", op_cond_syntax_16(ITCOND), if H then rd.hsyntax else rd.syntax endif, rm.syntax)
	image = format("01000110%1b%s%s", H, rm.image, rd.image)
	d = rd + if H then 8 else 0 endif
	action = {
		TMP_SWORD = Get_ARM_GPR(rm);
		Set_ARM_GPR(d, TMP_SWORD);
	}

op MUL_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
    ITCOND = "f_get_update_ITSTATE"()
    syntax = format("mul%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rm.syntax)
	image = format("0100001101%s%s", rm.image, rd.image)
	action = {
	       TMP_REG1 = GPR[rd];
	       TMP_REG1= GPR[rm] * TMP_REG1;
	        NFLAG = TMP_REG1<31..31>;
		 if TMP_REG1 == 0 then
		    ZFLAG = 1;
		 else
		    ZFLAG = 0;
		 endif;
		 GPR[rd] = TMP_REG1;

	}

op MVN_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("mvn%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rm.syntax)
	image = format("0100001111%s%s", rm.image, rd.image)
	action = {
	       TMP_REG1 = ~GPR[rm];
	       NFLAG = TMP_REG1<31..31>;
		 if TMP_REG1 == 0 then
		    ZFLAG = 1;
		 else
		    ZFLAG = 0;
		 endif;
		 GPR[rd] = TMP_REG1;

	}

op NEG_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("rsb%s %s, %s, #0", op_cond_syntax_16(ITCOND), rd.syntax, rm.syntax)
	image = format("0100001001%s%s", rm.image, rd.image)
	action = {
		TMP_REG1 = GPR[rm];
		TMP_SWORD = 0 - TMP_REG1;
		NFLAG = TMP_SWORD<31..31>;
		if TMP_SWORD == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd] = TMP_SWORD;
		CFLAG = CarryFromSub(0, TMP_REG1, TMP_SWORD);
		VFLAG = OverflowFromSub(0, TMP_REG1, TMP_SWORD);
	}

op ORR_thumb(rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("orr%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rm.syntax)
	image = format("0100001100%s%s", rm.image, rd.image)
	action = {
		TMP_REG1 = GPR[rd] | GPR[rm];
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd] = TMP_REG1;
	}


op POP_thumb(P: setR_T, llist: THUMB_REG_LIST)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("pop%s {%s%s}", op_cond_syntax_new(ITCOND), llist.syntax,
		if !P then "" else if llist then ", pc" else "pc" endif endif)
	image = format("1011 1 10 %s %s", P.image, llist.image)
	action = {
		// Compute number of set bits in the register list to compute the end address
		TMP_REGLIST = llist;
		TMP_IMM  = 0;
		TMP_SETBIT = 0;
		number_of_set_bits_in;

		TMP_REGLIST = llist;
		TMP_START_ADDR = Get_ARM_GPR(13);
		TMP_END_ADDR = TMP_START_ADDR + ((P + TMP_SETBIT) * 4) ;
		TMP_IMM = 0;
		boucle;

		if (P == 1) then
			TMP_REG1 = M32[TMP_START_ADDR];
			TBIT = TMP_REG1<0..0>;
			TFLAG = TBIT;
			BranchWritePC_thumb(M32[TMP_START_ADDR]);
		endif;
		Set_ARM_GPR(13, TMP_END_ADDR);

 		// Note that the assert mode is not implemented,
 		// programmer may take care of the address in paramater !
	}

	number_of_set_bits_in = {
		// Count the amount of bits into the list
		if (TMP_IMM < 8) then
			if (TMP_REGLIST & 1 == 1) then
				TMP_SETBIT = TMP_SETBIT + 1;
			endif;
		  	TMP_REGLIST = TMP_REGLIST >> 1;
			TMP_IMM = TMP_IMM + 1;
			number_of_set_bits_in;
		endif;
	}

    boucle = {
		if (TMP_IMM < 8) then
			if (TMP_REGLIST & 1 == 1) then
				Set_ARM_GPR(TMP_IMM, M32[TMP_START_ADDR]);
				TMP_START_ADDR = TMP_START_ADDR + 4;
			endif;
			TMP_REGLIST = TMP_REGLIST >> 1;
			TMP_IMM = TMP_IMM + 1;
			boucle;
		endif;
	}


op PUSH_thumb(P: setR_T, llist: THUMB_REG_LIST)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("push%s {%s%s}", op_cond_syntax_new(ITCOND), llist.syntax,
   			if !P then "" else if llist then ", lr" else "lr" endif endif)
   	image = format("1011010%s%s", P.image, llist.image)
   	action = {
   		//reg_list.action;
		//Compute number of set bits in the register list to compute the start address
		TMP_IMM  = 0;
		TMP_REGLIST = llist;
		TMP_SETBIT = 0;
		B15SET = 0;
		TMP_REG1 = Get_ARM_GPR(13);
		number_of_set_bits_in;
		TMP_START_ADDR = TMP_REG1 - ((P + TMP_SETBIT) * 4  ) ;
		TMP_END_ADDR = TMP_START_ADDR ;
		TMP_IMM = 0;
		TMP_REGLIST = llist;
		boucle;
		if (P == 1) then
			TMP_REG2 = Get_ARM_GPR(14);
			M32[TMP_START_ADDR] = TMP_REG2;
			TMP_START_ADDR = TMP_START_ADDR + 4;
		endif;
		Set_ARM_GPR(13, TMP_END_ADDR);
 		//Note that the assert mode is not implemented, programmer may take
		//		  care of the address in paramater !
	}
	number_of_set_bits_in = {
		//Count the amount of bits into the list
		if (TMP_IMM != 8) then
			if (TMP_REGLIST & 1 == 1) then
				TMP_SETBIT = TMP_SETBIT + 1;
				if (TMP_IMM == 7) then
					B15SET = 1;
				endif;
			endif;
			TMP_REGLIST = TMP_REGLIST >> 1;
			TMP_IMM = TMP_IMM + 1;
			number_of_set_bits_in;
		endif;
	}
    boucle = {
    	if (TMP_IMM != 8) then
    		if (TMP_REGLIST & 1 == 1) then
    			M32[TMP_START_ADDR] = GPR[TMP_IMM];
				TMP_START_ADDR = TMP_START_ADDR + 4;
			endif;
			TMP_REGLIST = TMP_REGLIST >> 1;
			TMP_IMM = TMP_IMM + 1;
			boucle;
		endif;
	}


op REV_thumb(rd: REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("rev%s %s, %s", op_cond_syntax_new(ITCOND), rd, rm) // REV<c> <Rd>,<Rm>
	image = format("1011 1010 00 %s %s", rm, rd)
	action = {
		TMP_UREG1 = Get_ARM_GPR(rm);

		TMP_UREG2<31..24> = TMP_UREG1<7..0>;
		TMP_UREG2<23..16> = TMP_UREG1<15..8>;
		TMP_UREG2<15..8> = TMP_UREG1<23..16>;
		TMP_UREG2<7..0> = TMP_UREG1<31..24>;

		Set_ARM_GPR(rd, TMP_UREG2);
	}


op REV16_thumb(rd: REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("rev16%s %s, %s", op_cond_syntax_new(ITCOND), rd, rm) // REV16<c> <Rd>,<Rm>
	image = format("1011 1010 01 %s %s", rm, rd)
	action = {
		TMP_UREG1 = Get_ARM_GPR(rm);

		TMP_UREG2<31..24> = TMP_UREG1<23..16>;
		TMP_UREG2<23..16> = TMP_UREG1<31..24>;
		TMP_UREG2<15..8> = TMP_UREG1<7..0>;
		TMP_UREG2<7..0> = TMP_UREG1<15..8>;

		Set_ARM_GPR(rd, TMP_UREG2);
	}


op REVSH_thumb(rd: REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("revsh%s %s, %s", op_cond_syntax_new(ITCOND), rd, rm) // REVSH<c> <Rd>,<Rm>
	image = format("1011 1010 11 %s %s", rm, rd)
	action = {
		TMP_UREG1 = Get_ARM_GPR(rm);

		TMP_UREG2<31..8> = SignExtend(TMP_UREG1<7..0>,24);
		TMP_UREG2<7..0> = TMP_UREG1<15..8>;

		Set_ARM_GPR(rd, TMP_UREG2);
	}


op ROR_thumb( rd : REG_THUMB_INDEX, rs : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("ror%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rs.syntax)
	image = format("0100000111%s%s", rs.image, rd.image)
	action = {
		TMP_IMM =  GPR[rs]<7..0>;
		TMP_FIVE = GPR[rs]<4..0>;
		TMP_REG1 = GPR[rd];
		if (TMP_IMM == 0) then
		else
			if (TMP_FIVE == 0) then
				//  TMP_IMM2 =  TMP_IMM - 1;
				CFLAG = TMP_REG1<31..31>;
			else
				TMP_IMM2 = TMP_FIVE - 1;
				// in the next line, index was missing after GPR
				// not sure if [rd] is the good one
				CFLAG = GPR[rd]<TMP_IMM2..TMP_IMM2>;
				TMP_REG1 = TMP_REG1 >>> TMP_FIVE;
			endif;
		endif;
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		GPR[rd]= TMP_REG1;
	}


op SBC_thumb( rd : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("sbc%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rm.syntax)
	image = format("0100000110%s%s", rm.image, rd.image)
	action = {
		TMP_REG1 = GPR[rd];
		TMP_REG2 = GPR[rm];
		TMP_BIT = !CFLAG;
		TMP_SWORD = TMP_REG1 - TMP_REG2 - !CFLAG;
		TMP_REG1 = TMP_SWORD;
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
		// a revoir \
		CFLAG =  ! CarryFromSub(TMP_REG1,TMP_REG1, TMP_BIT);
		VFLAG = OverflowFromSub(TMP_REG1,TMP_REG1,TMP_BIT);
	}

op STMIA_thumb(rn: REG_THUMB_INDEX, llist: THUMB_REG_LIST)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("stmia%s %s!, {%s}", op_cond_syntax_new(ITCOND), rn.syntax, llist.syntax)
	image = format("11000%s%s", rn.image, llist.image)
	action = {
		//Compute number of set bits in the register list to compute the start address
		TMP_REGLIST = llist;
		TMP_IMM  = 0;
		TMP_SETBIT = 0;
		B15SET = 0;
		number_of_set_bits_in;

		TMP_REGLIST = llist;
		TMP_REG1 = GPR[rn];
		TMP_START_ADDR = TMP_REG1;
		TMP_END_ADDR = TMP_REG1 + (TMP_SETBIT * 4) - 4;
		TMP_IMM = 0;
		boucle;
		TMP_END_ADDR = TMP_START_ADDR - 4;
		GPR[rn] = TMP_REG1 + TMP_SETBIT * 4;
		//Note that the assert mode is not implemented, programmer may take
		//		  care about the address in paramater !
		}
	number_of_set_bits_in = {
		//Count the amount of bits into the list
		if (TMP_IMM != 8) then
			if (TMP_REGLIST & 1 == 1) then
				TMP_SETBIT = TMP_SETBIT + 1;
				if (TMP_IMM == 7) then
					B15SET = 1;
				endif;
			endif;
			TMP_REGLIST = TMP_REGLIST >> 1;
			TMP_IMM = TMP_IMM + 1;
			number_of_set_bits_in;
		endif;
	}
	boucle = {
		if (TMP_IMM != 8) then
			if (TMP_REGLIST & 1 == 1) then
				M32[TMP_START_ADDR] = GPR[TMP_IMM] ;
				TMP_START_ADDR = TMP_START_ADDR + 4;
			endif;
			TMP_REGLIST = TMP_REGLIST >> 1;
			TMP_IMM = TMP_IMM + 1;
			boucle;
		endif;
	}

op STR_thumb = STR_imm_thumb | STR_shr_thumb | STR_imm2_thumb

op STR_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("str%s %s, [%s, #0x%x]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, imm*4)
	image = format("01100%s%s%s", imm.image, rn.image, rd.image)
	action = {
		TMP_START_ADDR  =  GPR[rn] + imm * 4;
		if ((TMP_START_ADDR & 3 ) == 0) then
			M32[TMP_START_ADDR] =  GPR[rd];
		else
			M32[TMP_START_ADDR] = UNPREDICTABLE;
		endif;
	}

op STR_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("str%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0101000%s%s%s", rm.image, rn.image, rd.image)
	action = {
		TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		if ((TMP_START_ADDR & 3 ) == 0) then
			M32[TMP_START_ADDR] = GPR[rd];
		else
			M32[TMP_START_ADDR] = UNPREDICTABLE;
		endif;
	}

op STR_imm2_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("str%s %s, [sp, #%d]", op_cond_syntax_new(ITCOND), rd.syntax, imm*4)
	image = format("10010%s%s", rd.image, imm.image)
	action = {
		TMP_REG1 = Get_ARM_GPR(13); // SP
		TMP_START_ADDR = TMP_REG1 + imm *4;
		if ((TMP_START_ADDR & 3 ) == 0) then
			M32[TMP_START_ADDR] = GPR[rd];
		else
			M32[TMP_START_ADDR] = UNPREDICTABLE;
		endif;
	}


op STRB_thumb = STRB_imm_thumb | STRB_shr_thumb

op STRB_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("strb%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, imm.syntax)
	image = format("01110%s%s%s", imm.image, rn.image, rd.image)
	action = {
		TMP_START_ADDR  =  GPR[rn] + imm ;
		TMP_IMM2 = GPR[rd]<7..0>;
		M[TMP_START_ADDR] = TMP_IMM2;
	}

op STRB_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("strb%s %s, [%s, %s]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0101010%s%s%s", rm.image, rn.image, rd.image)
	action = {
		TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		TMP_IMM2 = GPR[rd]<7..0>;
		M[TMP_START_ADDR] = TMP_IMM2;
	}


op STRH_thumb = STRH_imm_thumb | STRH_shr_thumb

op STRH_imm_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM5)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("strh%s %s, [%s, #0x%x]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, imm*2)
	image = format("10000%s%s%s", imm.image, rn.image, rd.image)
	action = {
		TMP_START_ADDR  =  GPR[rn] + imm * 2;
		TMP_REGLIST = GPR[rd]<15..0>;
		if ((TMP_START_ADDR & 3 ) == 0) then
			M16[TMP_START_ADDR] = TMP_REGLIST;
		else
			M16[TMP_START_ADDR] = UNPREDICTABLE;
		endif;
	}


op STRH_shr_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm : REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("strh%s %s, [%s, %s ]", op_cond_syntax_new(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0101001%s%s%s", rm.image, rn.image, rd.image)
	action = {
		TMP_START_ADDR  =  GPR[rn] + GPR[rm];
		TMP_REGLIST = GPR[rd]<15..0>;
		if ((TMP_START_ADDR & 3 ) == 0) then
			M16[TMP_START_ADDR] = TMP_REGLIST;
		else
			M16[TMP_START_ADDR] = UNPREDICTABLE;
		endif;
	}


op SUB_thumb =  SUB_imm1_thumb | SUB_imm2_thumb | SUB_imm3_thumb
|  SUB_reg_thumb

op SUB_imm1_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, imm: IMM3)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("sub%s %s, %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rn.syntax, imm.syntax)
	image = format("0001111%s%s%s", imm.image, rn.image, rd.image)
	action = {
		TMP_REG1 = Get_THUMB_GPR(rd);
		TMP_REG2 = Get_THUMB_GPR(rn);
		TMP_SWORD = TMP_REG2 - imm;
		GPR[rd] = TMP_SWORD;
		CFLAG =  CarryFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		VFLAG = OverflowFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		TMP_REG1 = Get_THUMB_GPR(rd);
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}

op SUB_imm2_thumb( rd : REG_THUMB_INDEX, imm: IMM8)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("sub%s %s, %s", op_cond_syntax_16(ITCOND), rd.syntax,imm.syntax)
	image = format("00111%s%s", rd.image, imm.image)
	action = {
		TMP_REG1 = Get_THUMB_GPR(rd);
		TMP_SWORD = TMP_REG1 - imm;
		GPR[rd] = TMP_SWORD;
		CFLAG =  CarryFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		VFLAG = OverflowFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		TMP_REG1 = GPR[rd];
		NFLAG = TMP_REG1<31..31>;
		if TMP_REG1 == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}

op SUB_reg_thumb( rd : REG_THUMB_INDEX, rn : REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("sub%s %s, %s, %s", op_cond_syntax_16(ITCOND), rd.syntax, rn.syntax, rm.syntax)
	image = format("0001101%s%s%s", rm.image, rn.image, rd.image)
	action = {
		TMP_REG1 = GPR[rm];
		TMP_REG2 = GPR[rn];
		TMP_SWORD = TMP_REG2 - TMP_REG1;
		GPR[rd] = TMP_SWORD;
		CFLAG =  CarryFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		VFLAG = OverflowFromSub(TMP_REG2,TMP_REG1,TMP_SWORD);
		NFLAG = TMP_SWORD<31..31>;
		if TMP_SWORD == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}


// SUB (SP minus immediate) in armv7.
op SUB_imm3_thumb( imm: IMM7)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("sub%s sp, #%d", op_cond_syntax_new(ITCOND), imm*4)
	image = format("101100001%s", imm.image)
	action = {
		TMP_REG1 = Get_ARM_GPR(13);
		TMP_SWORD = TMP_REG1 - coerce(u32, imm :: 0b00);
		Set_ARM_GPR(13, TMP_SWORD);
	}


//TODO: delete SWI -> see B_T1_thumb: svc
op SWI_thumb(imm: IMM8)
   ITCOND = 0
   syntax = format("swi %s", imm.syntax)
   image = format("11011111%s",imm.image)
   action =
	{
		//GPR[24] = NPC;
		//Uspsr[0] = Ucpsr;
		//MBITS = mode_supervisor;
		//TFLAG = 0;
		//IFLAG = 1;
		//Interruption table must be defined !
		//if (hivector == 1) then
		//	NPC = 0xFFFF0008;
		//else
		//	NPC = 0x00000008;
		//endif;
        	//"swi_impl"(imm);
	}


op SXTB_thumb( rd : REG_THUMB_INDEX,  rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("sxtb%s %s, %s", op_cond_syntax_new(ITCOND),rd.syntax, rm.syntax)
	image = format("1011 0010 01 %s %s", rm.image, rd.image)
	action = {
		TMP_REG1 = Get_ARM_GPR(rm);
		TMP_REG3 = SignExtend(TMP_REG1<7..0>, 32);
		Set_ARM_GPR(rd, TMP_REG3);
	}

op SXTH_thumb( rd : REG_THUMB_INDEX,  rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("sxth%s %s, %s", op_cond_syntax_new(ITCOND),rd.syntax, rm.syntax)
	image = format("1011 0010 00 %s %s", rm.image, rd.image)
	action = {
		TMP_REG1 = Get_ARM_GPR(rm);
		TMP_REG3 = SignExtend(TMP_REG1<15..0>, 32);
		Set_ARM_GPR(rd, TMP_REG3);
	}


op TST_thumb(rn : REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("tst%s %s, %s", op_cond_syntax_new(ITCOND), rn.syntax, rm.syntax)
	image = format("0100001000%s%s", rm.image,  rn.image)
	action = {
		TMP_REG2 = GPR[rn];
		TMP_REG1 = GPR[rm];
		Temp = TMP_REG2 & TMP_REG1;
		NFLAG = Temp<31..31>;
		if Temp == 0 then
			ZFLAG = 1;
		else
			ZFLAG = 0;
		endif;
	}

op NOP_thumb()
	ITCOND = 0
	syntax = "nop"
	image = "1011 1111 0000 0000"
	action = {}


// From Jerabek
op NOP_thumb_jer(firstcond: card(4), mask: card(4))
	ITCOND = "f_get_update_ITSTATE"()
	syntax = switch(firstcond::mask) {
		case 0b00000000: format("nop%s",op_cond_syntax_new(ITCOND))
		case 0b00100000: format("wfe%s",op_cond_syntax_new(ITCOND))
		case 0b00110000: format("wfi%s",op_cond_syntax_new(ITCOND))
		case 0b00010000: format("yield%s",op_cond_syntax_new(ITCOND))
		default: if(mask != 0b0000) then
			format("it%s %s%s", IT_xyz_syntax(firstcond,mask),
					condition_syntax(firstcond),
					if("f_set_ITSTATE"(firstcond::mask)) then "" else "" endif)
			else "unknown" endif
		}
	image = format("1011 1111 %4b %4b", firstcond, mask)
	action= {
		//TODO

		// it instruction
		if(mask != 0b0000) then
				ITSTATE<7..0> = firstcond::mask;
		endif;
	}


// From Jerabek
op UXTB_thumb(rd: REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("uxtb%s %s, %s", op_cond_syntax_new(ITCOND),rd.syntax, rm.syntax)
	image = format("1011 0010 11 %s %s", rm.image, rd.image)
	action = {
		TMP_UREG1 = Get_ARM_GPR(rm);
		TMP_UREG3 = ZeroExtend(TMP_UREG1<7..0>, 32);
		Set_ARM_GPR(rd, TMP_UREG3);
	}


// From Jerabek
op UXTH_thumb(rd: REG_THUMB_INDEX, rm: REG_THUMB_INDEX)
	ITCOND = "f_get_update_ITSTATE"()
	syntax = format("uxth%s %s, %s", op_cond_syntax_new(ITCOND),rd.syntax, rm.syntax)
	image = format("1011 0010 10 %s %s", rm.image, rd.image)
	action = {
		TMP_UREG1 = Get_ARM_GPR(rm);
		TMP_UREG3 = ZeroExtend(TMP_UREG1<15..0>, 32);
		Set_ARM_GPR(rd, TMP_UREG3);
	}
